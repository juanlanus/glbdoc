=~=~=~=~=~=~=~=~=~=~=~= PuTTY log 2014.06.03 18:09:47 =~=~=~=~=~=~=~=~=~=~=~=
login as: icjlud
Using keyboard-interactive authentication.
Password: 
Last login: Tue Jun  3 13:11:12 2014 from 172.16.10.12
Sun Microsystems Inc.   SunOS 5.10      Generic January 2005
You have new mail.
COBJVM=sun_142
JAVA_HOME=/usr/j2se
LD_LIBRARY_PATH=/usr/j2se/jre/lib/sparc:/usr/j2se/jre/lib/sparc/client:/usr/j2se/jre/lib/sparc/native_threads:/usr/j2se/jre/lib/sparc:/opt/mfocus/des/cobol/lib:/opt/IBM/db2/V9.7/lib:/export/home/db2inst1/sqllib/lib64:/export/home/db2inst1/sqllib/lib32
PATH=/usr/j2se/jre/sh:/usr/j2se/sh:/usr/j2se/bin:/usr/j2se/jre/bin:/opt/mfocus/des/cobol/lib:/opt/mfocus/des/cobol/bin:/usr/bin:/bin:/usr/bin:/d/iccol/desarrollo/macros:/d/iccol/desarrollo/utiles:/opt/bin:/usr/sbin:/usr/lib:/usr/ccs/bin:/opt/SUNWspro/bin:/usr/jdk/latest/bin:/usr/local/bin:/usr/j2se/bin:/usr/openwin/bin:.:/export/home/db2inst1/sqllib/bin:/export/home/db2inst1/sqllib/adm:/export/home/db2inst1/sqllib/misc
CLASSPATH=/opt/mfocus/des/cobol/lib/mfcobol.jar:.:/usr/j2se/jre/lib/rt.jar:/opt/mfocus/des/cobol/lib/mfimtk.jar:/opt/mfocus/des/cobol/lib/xerces.jar:/opt/mfocus/des/cobol/lib/castor-0_9_4_1-xml.jar:/opt/mfocus/des/cobol/lib/mfcobol.jar:/usr/j2se/jre/lib/dt.jar:/usr/j2se/jre/lib/rt.jar:/d/iccol/desarrollo/java/server:/export/home/db2inst1/sqllib/java/db2java.zip:/export/home/db2inst1/sqllib/java/db2jcc.jar:/export/home/db2inst1/sqllib/java/sqlj.zip:/export/home/db2inst1/sqllib/function:/export/home/db2inst1/sqllib/java/db2jcc_license_cu.jar:.
COBCPY=/opt/mfocus/des/cobol/cpylib:/opt/mfocus/des/cobol/cpylib:/d/iccol/desarrollo/copys/pais:/d/iccol/desarrollo/copys
Java version = 1.4.2_19
Java vendor = Sun Microsystems Inc.
Java OS name = SunOS
Java OS arch = sparc
Java OS version = 5.10

  ####    ####   #####   ######   ####
 #    #  #    #  #    #  #       #
 #       #    #  #    #  #####    ####
 #       #    #  #    #  #            #
 #    #  #    #  #    #  #       #    #
  ####    ####   #####   ######   ####

 #####
#     #   ####   #        ####   #    #  #####      #      ##
#        #    #  #       #    #  ##  ##  #    #     #     #  #
#        #    #  #       #    #  # ## #  #####      #    #    #
#        #    #  #       #    #  #    #  #    #     #    ######
#     #  #    #  #       #    #  #    #  #    #     #    #    #
 #####    ####   ######   ####   #    #  #####      #    #    #

 #####
#     #   ####   #    #  #####      #    #         ##     ####      #     ####
#        #    #  ##  ##  #    #     #    #        #  #   #    #     #    #    #
#        #    #  # ## #  #    #     #    #       #    #  #          #    #    #
#        #    #  #    #  #####      #    #       ######  #          #    #    #
#     #  #    #  #    #  #          #    #       #    #  #    #     #    #    #
 #####    ####   #    #  #          #    ######  #    #   ####      #     ####

 #####                                           #####  #         ###
#     #  #    #  #    #          #    #         #     # #    #   #   #
#        #    #  ##   #          #    #               # #    #  #     #
 #####   #    #  # #  #          #    #          #####  #    #  #     #
      #  #    #  #  # #          #    #   ###   #       ####### #     #
#     #  #    #  #   ##           #  #    ###   #            #   #   #
 #####    ####   #    # #######    ##     ###   #######      #    ###

icjlud@codes /d/iccol/desarrollo
$ . viset
viset running
/d/iccol/desarrollo>ma
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>/vi shvi sh-PE-Ripley
"sh-PE-Ripley" 752 lines, 26744 characters # /d/iccol/desarrollo/macros/sh-PE-Ripley
#sh-PE-Ripley.V.1.0001
#*******************************************************************************
#SHELL-ID:     sh-PE-Ripley
#DATE-WRITTEN: 2014/05/23
#LAST-UPDATE:  2014/05/23
#AUTHOR:Globant - JL
#*******************************************************************************
# Definición de constantes
    debug=0# cero para producción, 1 para test
    doCuu="1"# reposicionar el cursor luego de un error
    NOHUP=""# contiene "nohup" en producción, null para test
    cancelado="0"# las funciones ponen "1" para cancelar todo
    P_SERVER_DEV="codes"# hostname de la máquina de develop
    raya="----------------------------------------------------------------------"
    ASCIIBanner="
######  #######    ######
#     # ##     # # #####  ####### #   #
#     # ##     # # #    # ### #
######  ###########  # #    # ######    #
###   #   # #####  ###
###    #  # ####
########    #     # # ####### ######   #
"

# Parámetros y sus valores iniciales
    FECHA_PROC=$(date '+%Y%m%d')
#   "I": la lista de IDs es interna  "E": provista x cliente
    BASE="E"
#si BASE="E": archivo y estructura ("1": 1-11 o "2": 1-11-45)
NOM_ARCHIVO=" "
TIPO_ARCHIVO="2"
#si BASE="I": "N": extracción x NIT  "C": por cod suscriptor
TIPO_EXTRACT="N"
#si TIPO_EXTRACT="C": NIT (9) o Cod Suscriptor (6), según TIPO_EXTRACTID_EXTRACT=" "
#   Tipo de proceso "A": actual  "H": histórico
    TIPO_PROC="A"
#Si TIPO_PROC="H": la fecha inicio de proceso histórico
FECHA_INICIO=" "

readBASE() {
#*******************************************************************************
# Lee el valor de BASE hasta que es OK {I|C} o el ope cancela
#*******************************************************************************
    loopEnd="0"
    while [[ $loopEnd = "0" ]]
    do
  echo " ""sh-PE-Ripley" 752 lines, 26744 characters/\<cat\>echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {/# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************?echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {/# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************?echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {/# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************/Address search hit BOTTOM without matching pattern?echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {?Address search hit TOP without matching pattern/# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************?echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>. sh-pva
/d/iccol/desarrollo/macros>ls $TEMPORALES/pripl*
/dicregis/pva/temporales/pripley.DATINF
/dicregis/pva/temporales/pripley.ESTADI
/dicregis/pva/temporales/pripley.inc
/dicregis/pva/temporales/pripley.PREDHD
/dicregis/pva/temporales/pripley.prn
/dicregis/pva/temporales/pripley.val
/dicregis/pva/temporales/pripley.vre
/dicregis/pva/temporales/pripley1.COP
/dicregis/pva/temporales/pripley1.DATINF
/dicregis/pva/temporales/pripley1.ESTADI
/dicregis/pva/temporales/pripley1.inc
/dicregis/pva/temporales/pripley1.log
/dicregis/pva/temporales/pripley1.ok
/dicregis/pva/temporales/pripley1.PREDHD
/dicregis/pva/temporales/pripley1.prn
/dicregis/pva/temporales/pripley1.ULTIMO
/dicregis/pva/temporales/pripley1.val
/dicregis/pva/temporales/pripley1.vre
/dicregis/pva/temporales/pripley11.inc
/dicregis/pva/temporales/pripley11.log
/dicregis/pva/temporales/pripley11.PREDHD
/dicregis/pva/temporales/pripley11.prn
/dicregis/pva/temporales/pripley11.ULTIMO
/dicregis/pva/temporales/pripley11.val
/dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>view /dicregis/pva/temporales/pripley11.prn
"/dicregis/pva/temporales/pripley11.prn" [Read only] 124731 lines, 1621514 characters VALIDAR=NO^M
100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914
100000058754
100000059035"/dicregis/pva/temporales/pripley11.prn" [Read only] 124731 lines, 1621514 characters:q/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>view /dicregis/pva/temporales/pripley11.prn/d/iccol/desarrollo/macros>ls $TEMPORALES/pripl*                      /d/iccol/desarrollo/macros>
/dicregis/pva/temporales/pripley.DATINF
/dicregis/pva/temporales/pripley.ESTADI
/dicregis/pva/temporales/pripley.inc
/dicregis/pva/temporales/pripley.PREDHD
/dicregis/pva/temporales/pripley.prn
/dicregis/pva/temporales/pripley.val
/dicregis/pva/temporales/pripley.vre
/dicregis/pva/temporales/pripley1.COP
/dicregis/pva/temporales/pripley1.DATINF
/dicregis/pva/temporales/pripley1.ESTADI
/dicregis/pva/temporales/pripley1.inc
/dicregis/pva/temporales/pripley1.log
/dicregis/pva/temporales/pripley1.ok
/dicregis/pva/temporales/pripley1.PREDHD
/dicregis/pva/temporales/pripley1.prn
/dicregis/pva/temporales/pripley1.ULTIMO
/dicregis/pva/temporales/pripley1.val
/dicregis/pva/temporales/pripley1.vre
/dicregis/pva/temporales/pripley11.inc
/dicregis/pva/temporales/pripley11.log
/dicregis/pva/temporales/pripley11.PREDHD
/dicregis/pva/temporales/pripley11.prn
/dicregis/pva/temporales/pripley11.ULTIMO
/dicregis/pva/temporales/pripley11.val
/dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
echo "la fecha desde debe ser anterior a la actual"tput bel
[ $doCuu = "1" ] &&  tput cuu 8else
# todo bien
FECHA_INICIO=$FECHA_INICIOnewFECHA_INICIO_YYYYMM=$FECHA_INICIOnewYYYYMMloopEnd="1"fi
fi
    done
}




paramsGet() {
#*******************************************************************************
# Lee los parámetros de la corrida anterior
#*******************************************************************************
#   asegura que exista el arch de parámetros general
    [[ ! -f $0.parm ]] && touch $0.parm
#   lee los parámetros
    params=$(cat $0.parm)
    echo '>>>> params: ' "$params"
#   separa los parámetros según su posición
    BASE=$(echo "$params" | cut -d ";" -f1)
    NOM_ARCHIVO=$(echo "$params" | cut -d ";" -f2)
    TIPO_ARCHIVO=$(echo "$params" | cut -d ";" -f3)
    TIPO_EXTRACT=$(echo "$params" | cut -d ";" -f4)
    ID_EXTRACT=$(echo "$params" | cut -d ";" -f5)
    TIPO_PROC=$(echo "$params" | cut -d ";" -f6)
    FECHA_INICIO=$(echo "$params" | cut -d ";" -f7)
}

paramsPut() {
#*******************************************************************************
# Guarda los parámetros de la corrida en el archivo .parm
#*******************************************************************************
allParms=$BASE";"${NOM_ARCHIVO:-" "}";"${TIPO_ARCHIVO:-" "}";"
allParms=$allParms${TIPO_EXTRACT:-" "}";"${ID_EXTRACT:-" "}";"
allParms=$allParms$TIPO_PROC";"${FECHA_INICIO:-" "}
echo $allParms
echo "file:" $0.parm " in:" $(pwd)
echo $allParms >| $0.parm# para pruebas
echo $allParms >| $archivo.parm
}

paramsPrint() {/# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgls $TEMPORALES/pripl*
/dicregis/pva/temporales/pripley.DATINF
/dicregis/pva/temporales/pripley.ESTADI
/dicregis/pva/temporales/pripley.inc
/dicregis/pva/temporales/pripley.PREDHD
/dicregis/pva/temporales/pripley.prn
/dicregis/pva/temporales/pripley.val
/dicregis/pva/temporales/pripley.vre
/dicregis/pva/temporales/pripley1.COP
/dicregis/pva/temporales/pripley1.DATINF
/dicregis/pva/temporales/pripley1.ESTADI
/dicregis/pva/temporales/pripley1.inc
/dicregis/pva/temporales/pripley1.log
/dicregis/pva/temporales/pripley1.ok
/dicregis/pva/temporales/pripley1.PREDHD
/dicregis/pva/temporales/pripley1.prn
/dicregis/pva/temporales/pripley1.ULTIMO
/dicregis/pva/temporales/pripley1.val
/dicregis/pva/temporales/pripley1.vre
/dicregis/pva/temporales/pripley11.inc
/dicregis/pva/temporales/pripley11.log
/dicregis/pva/temporales/pripley11.PREDHD
/dicregis/pva/temporales/pripley11.prn
/dicregis/pva/temporales/pripley11.ULTIMO
/dicregis/pva/temporales/pripley11.val
/dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>k^[  /d/iccol/desarrollo/macros>kls $TEMPORALES/pripl*ls -$TEMPORALES/pripl*l$TEMPORALES/pripl* $TEMPORALES/pripl*
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 16:03 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2033 Jun  3 16:03 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icdgd    icdatacr  301840 May 30 15:37 /dicregis/pva/temporales/pripley1.inc
-rw-rw-r--   1 ichdd    icdatacr    2604 May 30 15:48 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr 9944370 May 30 15:48 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 May 30 15:48 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr 12989915 May 30 15:37 /dicregis/pva/temporales/pripley1.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 15:37 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr  301840 Jun  3 16:09 /dicregis/pva/temporales/pripley11.inc
-rw-rw-r--   1 icdgd    icdatacr    2505 Jun  3 16:09 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 14954496 Jun  3 16:17 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621514 Jun  3 16:09 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:17 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr 12989915 Jun  3 16:09 /dicregis/pva/temporales/pripley11.val
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:09 /dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>echo $DATOS
/d/iccol/desarrollo/datos
/d/iccol/desarrollo/macros>archivo_prn="pripley11.prn"     "
/d/iccol/desarrollo/macros>PESVNO_INPUT=${archivo}"VALI.prn"
/d/iccol/desarrollo/macros>cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT_ZZZ    
cat: cannot open pripley11
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>/sh. sh-pvavi sh-PE-Ripleysh-PE-Ripley   
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:f^[[D   fiif
El archivo if no se encuentra
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
cp: cannot access pripley1
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1.prn pripley1.val pripley1.inc 10 2

real    0m9.26s
user    0m5.90s
sys     0m3.05s
PESVNO - registros válidos: 122770  inconsistentes: 1960  total: 124731
!!........EL ORDEN DE LOS PARAMETROS ES ........!!
!!..ENTRADA CORRECTOS INCORRECTOS TARIFA BLOQUES.!!
REGISTROS RECIBIDOS ORIGINALMENTE:
124732
ARCHIVO: pripley1.prn                  
Registro  control==> 000001 (VALIDAR=NO)
Registros Tipo 5           ==> 122770
Registros Tipo 6           ==> 001957
Registros Tipo 7           ==> 000003
Registros Tipo 5 repetidos ==> 000000
----------------------------------------------------------------------
SCOTBATCH: cálculo de scores
 
SCOTBATCH 201406 067 VAL pripley1.val
^C/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>cp pripley1.prn pripley1.in
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>cp pripley1.prn pripley1.infg                         sh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:pripley1.in 
El archivo pripley1.in no se encuentra
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:^C
/d/iccol/desarrollo/macros>cd $TEMPORALES
/dicregis/pva/temporales>cp pripley1.prn pripley1.in
/dicregis/pva/temporales>cd -
/d/iccol/desarrollo/macros
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>cd -cp pripley1.prn pripley1.incd $TEMPORALES             sh-PE-Ripley  
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:pripley1.in 
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:1
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.in<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.in;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.in
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
cp: cannot access pripley1
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1.prn pripley1.val pripley1.inc 10 2
^C
real    0m7.01s
user    0m4.58s
sys     0m2.34s
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************/\<sed\>    FECHA_PROC_YYYYMM=$(echo $FECHA_PROC  | cut -c1-6)clear
echo $raya
#   banner "PE Ripley"
    echo "$ASCIIBanner"
    echo $raya
    [[ $debug -eq 1 ]] && echo "DEBUG"

#*******************************************************************************
# Lectura de parámetros en la terminal
#*******************************************************************************
    leerParametros

#*******************************************************************************
# Nombres de los archivos, SANATA
#*******************************************************************************
    # la variable archivo es el nombre de la base, interna o del cliente,
    # y se usa para armar todos los demás nombres de archivos del proceso
    if [[ $BASE = "E" ]]
    then
# el nombre del archivo, sin extensión,  de la base externa
archivo=$NOM_ARCHIVO
archivo=$( echo $NOM_ARCHIVO | sed "s/\..*//" )
    else
# un nombre armado con "PERipley" y la fecha del día
# $$$$ no será posible ejecutar dos procesos en el mismo día
# $$$$ se puede agregar un $$ al file name, o la hora
# $$$$ se puede controlar si ya existe un archivo de hoy ...
archivo="PERipley"$FECHA_PROC
NOM_ARCHIVO=$archivo
    fi
# arma los nombres de los archivos del proceso en base al anterior
    archivo_prn=$archivo.prn
    archivo_val=$archivo.val
    archivo_inc=$archivo.inc

#*******************************************************************************
# Proceso histórico: ubica la SANATA que corresponde a la fecha inicial
# de proceso FECHA_INICIO
#    Ejemplos de variables exportadas:
#    DATABASE=/san_ata_2/200412/icdb
#    DATABASE=/san_ata_3/200512/icdb
#    EXTFH=/san_ata_3/200603/extfh.cfg
#    EXTFH=/san_ata_3/200601/extfh.cfg
#*******************************************************************************
    if [[ $TIPO_PROC = "H" ]]
    then
FECHA_INICIO_YYYYMM=$(echo $FECHA_INICIO | cut -c1-6 )
OPEN MODEif [[ $NOM_ARCHIVO != $archivo ]] 
OPEN MODEthen
OPEN MODE

if [[ $NOM_ARCHIVO != $archivo ]]
if [[ $NOM_ARCHIVO != $archivo ]]#    EXTFH=/san_ata_3/200601/extfh.cfg
if [[ $NOM_ARCHIVO != $archivo ]]#    EXTFH=/san_ata_3/200601/extfh.cfg   #*******************************************************************************   



archivo=$NOM_ARCHIVO    archivo=$NOM_ARCHIVO=INSERT MODEmv OAPPEND MODE  archivoINSERT MODE$
OPEN MODEfifi[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>man ksh
Reformatting page.  Please Wait... done

User Commands                                              ksh(1)

NAME
     ksh, rksh - KornShell,  a  standard/restricted  command  and
     programming language

SYNOPSIS
     /usr/bin/ksh [+ abCefhikmnoprstuvx] [+ o option]...
         [arg]...

     /usr/bin/ksh -c [+ abCefhikmnoprstuvx]
         [+ o option]... command_string
         [command_name [arg...]]

     /usr/xpg4/bin/sh [+ abCefhikmnoprstuvx]
         [+ o option]... [arg]...

     /usr/xpg4/bin/sh -c [+ abCefhikmnoprstuvx]
         [+ o option]... command_string
         [command_name [arg...]]

     /usr/bin/rksh [+ abCefhikmnoprstuvx] [+ o option]...
         [arg]...

     /usr/bin/rksh -c [+ abCefhikmnoprstuvx]
         [+ o option]... command_string
         [command_name [arg...]]

DESCRIPTION
     The /usr/xpg4/bin/sh utility is a standards compliant shell.
     This utility provides all the functionality of /usr/bin/ksh,
     except in cases where differences  in  behavior  exist.  See
     Arithmetic Expansions section for details.

     /usr/bin/ksh is a command and programming language that exe-
     cutes  commands  read  from  a terminal or a file. rksh is a
     restricted version of the command  interpreter  ksh;  it  is
     used  to set up login names and execution environments whose
     capabilities are more controlled than those of the  standard
     shell.  See  the Invocation section for the meaning of argu-
     ments to the shell.

  Definitions
     A metacharacter is one of the following characters:

SunOS 5.10          Last change: 29 Jun 2005                    1

--More--(1%)/comparisstring comparisonPattern not found/[[Regular expression botch/relartional operatorsPattern not foundUser Commands                                              ksh(1)

     ; & (   )   |   <   >      NEWLINE   SPACE   TAB

     A blank is a TAB or a SPACE. An identifier is a sequence  of
     letters,  digits,  or  underscores starting with a letter or
     underscore. Identifiers are used as names for functions  and
     variables.  A  word is a sequence of characters separated by
     one or more non-quoted metacharacters.

     A command is a sequence of characters in the syntax  of  the
     shell language. The shell reads each command and carries out
     the desired action either directly or by  invoking  separate
     utilities.  A  special-command  is a command that is carried
     out by the shell without creating a separate process. Except
     for  documented  side  effects, most special commands can be
     implemented as separate utilities.

  Commands
     A simple-command is  a  sequence  of  blank-separated  words
     which  can  be  preceded  by a variable assignment list. See
     Environment. The first word specifies the name of  the  com-
     mand  to  be  executed.  Except  as specified, the remaining
     words are passed as arguments to the  invoked  command.  The
     command  name  is  passed  as  argument 0 (see exec(2)). The
     value of a simple-command is its  exit  status  if  it  ter-
     minates normally. If it terminates abnormally due to receipt
     of a signal, the value is the signal number  plus  128.  See
     signal.h(3HEAD) for a list of signal values. Obviously, nor-
     mal exit status values 129 to 255  cannot  be  distinguished
     from  abnormal  exit caused by receiving signal numbers 1 to
     127.

     A pipeline is a sequence of one or more  commands  separated
     by  |.  The  standard output of each command but the last is
     connected by a pipe(2) to the standard  input  of  the  next
     command.  Each  command  is  run  as a separate process; the
     shell waits for the last  command  to  terminate.  The  exit
     status of a pipeline is the exit status of the last command.

     A list is a sequence of one or more pipelines  separated  by
     ;,  &,  &&, or ||, and optionally terminated by ;, &, or |&.
     Of these five symbols, ;, &, and |& have  equal  precedence,
     which is lower than that of && and ||. The symbols && and ||
     also have equal precedence. A semicolon (;)  causes  sequen-
     tial  execution  of the preceding pipeline; an ampersand (&)
     causes asynchronous  execution  of  the  preceding  pipeline
     (that  is, the shell does not wait for that pipeline to fin-
--More--(2%)     ish). The symbol |& causes  asynchronous  execution  of  the
     preceding   command   or   pipeline   with  a  two-way  pipe

SunOS 5.10          Last change: 29 Jun 2005                    2

User Commands                                              ksh(1)

     established to the parent shell.

     The standard input and output of the spawned command can  be
     written  to  and  read from by the parent shell using the -p
     option of the special commands read and print  described  in
     Special Commands. The symbol && (||) causes the list follow-
     ing it to be executed only if the preceding pipeline returns
     0  (or  a  non-zero) value. An arbitrary number of new-lines
     can appear in a list, instead of a semicolon, to  delimit  a
     command.

     A command is either a simple-command or one of  the  follow-
     ing.  Unless  otherwise stated, the value returned by a com-
     mand is that of the last simple-command executed in the com-
     mand.

     for identifier [ in word ... ] ; do list ; done

         Each time a for command is executed, identifier  is  set
         to the next word taken from the in word list. If in word
         ...  is omitted, then the for command  executes  the  do
         list once for each positional parameter that is set. See
         Parameter Substitution. Execution ends when there are no
         more words in the list.

     select identifier [ in word ... ] ; do list ; done

         A select command prints to standard error (file descrip-
         tor  2), the set of words, each preceded by a number. If
         in word ... is omitted, then the  positional  parameters
         are  used  instead.  See Parameter Substitution. The PS3
         prompt is printed and a line is read from  the  standard
         input. If this line consists of the number of one of the
         listed words, then the value of the variable  identifier
         is set to the word corresponding to this number. If this
         line is empty the selection list is printed again.  Oth-
         erwise  the  value  of the variable identifier is set to
         NULL. (See Blank Interpretation about NULL).   The  con-
         tents  of  the line read from standard input is saved in
         the shell variable REPLY. The list is executed for  each
         selection  until  a  break or EOF is encountered. If the
--More--(4%)         REPLY variable is set to NULL by the execution of  list,
         then the selection list is printed before displaying the
         PS3 prompt for the next selection.

     case word in [ pattern [ | pattern ] ) list ;; ] ... esac

         A case command executes the  list  associated  with  the

SunOS 5.10          Last change: 29 Jun 2005                    3

User Commands                                              ksh(1)

         first  pattern  that  matches word. The form of the pat-
         terns is the same as that used for file-name generation.
         See File Name Generation.

     if list ; then list ; [ elif list ; then list ; ...  ] [
     else list ; ] fi

         The list following if is executed and, if it returns  an
         exit  status  of 0, the list following the first then is
         executed. Otherwise, the list following elif is executed
         and, if its value is 0, the list following the next then
         is executed. Failing that, the else list is executed. If
         no  else list or then list is executed, then the if com-
         mand returns 0 exit status.

     while list ; do list ; done
     until list ; do list ; done

         A while command repeatedly executes the while list  and,
         if the exit status of the last command in the list is 0,
         executes the do list; otherwise the loop terminates.  If
         no  commands in the do list are executed, then the while
         command returns 0 exit status.  until  can  be  used  in
         place of while to negate the loop termination test.

     (list)

         Execute list in a separate environment. If two  adjacent
         open parentheses are needed for nesting, a space must be
         inserted to avoid arithmetic evaluation.

     {list}

         list is simply executed. Unlike the metacharacters ( and
         ),  {  and  }  are  reserved words and must occur at the
         beginning of a line or after a ; in order to  be  recog-
--More--(5%)         nized.

     [[expression]]

         Evaluates expression and  returns  0  exit  status  when
         expression  is  true.  See Conditional Expressions for a
         description of expression.

     function identifier { list ;}
     identifier( ) { list ;}

SunOS 5.10          Last change: 29 Jun 2005                    4

User Commands                                              ksh(1)

         Define a function which is referenced by identifier. The
         body  of  the function is the list of commands between {
         and }. See Functions.

     time pipeline

         The pipeline is executed and the elapsed time as well as
         the user and system time are printed to standard error.

     The following reserved words  are  only  recognized  as  the
     first word of a command and when not quoted:

       !          if       then     else    elif    fi      case
       esac       for      while    until   do      done    {   }
       function   select   time     [[  ]]

  Comments
     A word beginning with # causes that word and all the follow-
     ing characters up to a new-line to be ignored.

  Aliasing
     The first word of each command is replaced by the text of an
     alias  if  an alias for this word has been defined. An alias
     name consists of any number of  characters  excluding  meta-
     characters,  quoting  characters, file expansion characters,
     parameter and command substitution characters,  and  =.  The
     replacement  string  can  contain  any  valid  shell  script
     including the metacharacters listed above. The first word of
     each  command  in the replaced text, other than any that are
     in the process of being replaced, is tested for aliases.  If
     the  last  character  of the alias value is a blank then the
     word following the alias is also be checked for  alias  sub-
     stitution.  Aliases  can be used to redefine special builtin
--More--(6%)     commands but cannot be used to redefine the  reserved  words
     listed  above.  Aliases can be created, listed, and exported
     with the alias command and can be removed with  the  unalias
     command.  Exported  aliases  remain  in  effect  for scripts
     invoked by name, but  must  be  reinitialized  for  separate
     invocations  of the shell. See Invocation. To prevent infin-
     ite loops  in  recursive  aliasing,  if  the  shell  is  not
     currently  processing an alias of the same name, the word is
     replaced by the value of the alias; otherwise, it is not  be
     replaced.

     Aliasing is performed when scripts are read, not while  they
     are  executed.  Therefore,  for an alias to take effect, the

SunOS 5.10          Last change: 29 Jun 2005                    5

User Commands                                              ksh(1)

     alias definition command has to be executed before the  com-
     mand which references the alias is read.

     Aliases are frequently used as a short hand  for  full  path
     names.  An  option to the aliasing facility allows the value
     of the alias to be automatically set to the full pathname of
     the  corresponding command. These aliases are called tracked
     aliases. The value of a tracked alias is defined  the  first
     time  the  corresponding  command  is  looked up and becomes
     undefined each  time  the  PATH  variable  is  reset.  These
     aliases remain tracked so that the next subsequent reference
     redefines the value. Several tracked  aliases  are  compiled
     into  the shell. The -h option of the set command makes each
     referenced command name into a tracked alias.

     The  following  exported  aliases  are  compiled  into  (and
     built-in to) the shell but can be unset or redefined:

       autoload='typeset -fu'
       functions='typeset -f'
       history='fc -l'
       integer='typeset -i'
       nohup='nohup '
       r='fc -e -'

     An example concerning trailing blank characters and reserved
     words follows. If the user types:

       $ alias foo="/bin/ls "
       $ alias while="/"
--More--(8%)
     the effect of executing:

       $ while true
       > do
       > echo "Hello, World"
       > done

     is a never-ending sequence of Hello, World  strings  to  the
     screen. However, if the user types:

SunOS 5.10          Last change: 29 Jun 2005                    6

User Commands                                              ksh(1)

       $ foo while

     the result is an ls listing of /. Since the alias  substitu-
     tion  for  foo  ends  in a space character, the next word is
     checked for alias substitution. The next  word,  while,  has
     also been aliased, so it is substituted as well. Since it is
     not in the proper position as a  command  word,  it  is  not
     recognized as a reserved word.

     If the user types:

       $ foo; while

     while retains its normal reserved-word properties.

  Tilde Substitution
     After alias substitution is performed, each word is  checked
     to see if it begins with an unquoted ~. If it does, then the
     word up to a / is checked to see if it matches a user  name.
     If  a  match  is found, the ~ and the matched login name are
     replaced by the login directory of the matched user. This is
     called  a tilde substitution. If no match is found, the ori-
     ginal text is left unchanged. A ~ by itself, or in front  of
     a  /,  is  replaced  by  $HOME.  A ~ followed by a + or - is
     replaced by $PWD and $OLDPWD, respectively.

     In addition, tilde substitution is attempted when the  value
     of a variable assignment begins with a ~.

  Tilde Expansion
     A tilde-prefix consists of an unquoted  tilde  character  at
     the  beginning  of a word, followed by all of the characters
     preceding the first unquoted slash in the word, or  all  the
--More--(9%)     characters  in  the word if there is no slash. In an assign-
     ment, multiple tilde-prefixes can be used: at the  beginning
     of  the  word  (that  is,  following  the  equal sign of the
     assignment), following any unquoted colon or both. A  tilde-
     prefix  in an assignment is terminated by the first unquoted
     colon or slash. If none of  the  characters  in  the  tilde-
     prefix  are  quoted, the characters in the tilde-prefix fol-
     lowing the tilde are treated as a possible login  name  from
     the user database.

SunOS 5.10          Last change: 29 Jun 2005                    7

User Commands                                              ksh(1)

     A portable login name cannot contain characters outside  the
     set  given  in  the  description  of the LOGNAME environment
     variable. If the login name is null  (that  is,  the  tilde-
     prefix   contains  only  the  tilde),  the  tilde-prefix  is
     replaced by the value of the  variable  HOME.   If  HOME  is
     unset,  the  results  are unspecified. Otherwise, the tilde-
     prefix is replaced by a pathname of the home directory asso-
     ciated with the login name obtained using the getpwnam func-
     tion. If the system does not recognize the login  name,  the
     results are undefined.

     Tilde expansion generally occurs only at  the  beginning  of
     words,  but  an  exception  based on historical practice has
     been included:

       PATH=/posix/bin:~dgk/bin

     is eligible for tilde  expansion  because  tilde  follows  a
     colon  and  none  of the relevant characters is quoted. Con-
     sideration was given to prohibiting  this  behavior  because
     any of the following are reasonable substitutes:

       PATH=$(printf %s ~karels/bin : ~bostic/bin)
       for Dir in ~maart/bin ~srb/bin .
       do
           PATH=${PATH:+$PATH:}$Dir
       done

     With the first command, explicit colons are  used  for  each
     directory.  In all cases, the shell performs tilde expansion
     on each directory because all  are  separate  words  to  the
     shell.

     Expressions in operands such as:
--More--(10%)
       make -k mumble LIBDIR=~chet/lib

     do not qualify  as  shell  variable  assignments  and  tilde
     expansion  is  not  performed  (unless  the  command does so
     itself, which make does not).

     The special sequence  $~  has  been  designated  for  future
     implementations  to  evaluate  as  a  means of forcing tilde

SunOS 5.10          Last change: 29 Jun 2005                    8

User Commands                                              ksh(1)

     expansion in any word.

     Because of the requirement that the word not be quoted,  the
     following  are  not  equivalent;  only the last causes tilde
     expansion:

       \~hlj/   ~h\lj/   ~"hlj"/   ~hlj\/   ~hlj/

     The results of giving tilde with an unknown login  name  are
     undefined  because  the  KornShell ~+ and ~- constructs make
     use of this condition, but, in general it  is  an  error  to
     give an incorrect login name with tilde. The results of hav-
     ing HOME  unset  are  unspecified  because  some  historical
     shells treat this as an error.

  Command Substitution
     The standard output from a command enclosed  in  parenthesis
     preceded by a dollar sign (that is, $(command)) or a pair of
     grave accents (``) can be used as part or  all  of  a  word.
     Trailing  new-lines  are  removed.  In  the second (archaic)
     form, the string between the quotes is processed for special
     quoting characters before the command is executed. See Quot-
     ing. The command substitution $(cat file) can be replaced by
     the  equivalent but faster $(<file). Command substitution of
     most special  commands  that  do  not  perform  input/output
     redirection are carried out without creating a separate pro-
     cess.

     Command substitution allows the output of a  command  to  be
     substituted  in  place  of  the command name itself. Command
     substitution occurs when the command is enclosed as follows:

       $(command)

--More--(11%)     or (backquoted version):

       `command`

     The shell expands the command substitution by executing com-
     mand  in  a  subshell  environment and replacing the command
     substitution (the text of command plus the enclosing $()  or

SunOS 5.10          Last change: 29 Jun 2005                    9

User Commands                                              ksh(1)

     backquotes)  with the standard output of the command, remov-
     ing sequences of one or more newline characters at  the  end
     of  the substitution. Embedded newline characters before the
     end of the output is not be removed; however,  they  can  be
     treated  as  field  delimiters  and  eliminated during field
     splitting, depending on the value of IFS and quoting that is
     in effect.

     Within  the  backquoted  style  of   command   substitution,
     backslash shall retain its literal meaning, except when fol-
     lowed by:

       $     `     \

     (dollar-sign, backquote,  backslash).  The  search  for  the
     matching backquote is satisfied by the first backquote found
     without a preceding backslash.  During  this  search,  if  a
     non-escaped backquote is encountered within a shell comment,
     a here-document, an embedded  command  substitution  of  the
     $(command)  form,  or  a  quoted  string,  undefined results
     occur. A single- or double-quoted string  that  begins,  but
     does  not  end, within the `...` sequence produces undefined
     results.

     With the $(command) form, all characters following the  open
     parenthesis  to  the matching closing parenthesis constitute
     the command. Any valid shell script can be used for command,
     except:

         o    A script consisting solely of redirections produces
              unspecified results.

         o    See the restriction on single subshells.

     The results of command substitution are not field  splitting
     and  pathname  expansion  processed for further tilde expan-
--More--(12%)     sion, parameter expansion, command  substitution  or  arith-
     metic  expansion.  If  a  command substitution occurs inside
     double-quotes, it is not be performed on the results of  the
     substitution.

     Command substitution  can  be  nested.  To  specify  nesting
     within  the backquoted version, the application must precede
     the inner backquotes with backslashes; for example:

SunOS 5.10          Last change: 29 Jun 2005                   10

User Commands                                              ksh(1)

       `\`command\``

     The $() form of command substitution  solves  a  problem  of
     inconsistent behavior when using backquotes. For example:

     ____________________________________________________________
    |           Command                        Output           |
    |___________________________________________________________|
    | echo '\$x'                    \$x                         |
    | echo `echo '\$x'`             $x                          |
    | echo $(echo '\$x')            \$x                         |
    |___________________________________________________________|

     Additionally, the backquoted syntax has historical  restric-
     tions on the contents of the embedded command. While the new
     $() form can process any kind of valid embedded script,  the
     backquoted  form  cannot  handle  some  valid  scripts  that
     include  backquotes.  For  example,  these  otherwise  valid
     embedded scripts do not work in the left column, but do work
     on the right:

SunOS 5.10          Last change: 29 Jun 2005                   11

User Commands                                              ksh(1)

     ____________________________________________________________
    | echo `                        echo $(                     |
    | cat <<eeof                    cat <<eeof                  |
    | a here-doc with `             a here-doc with )           |
    | eof                           eof                         |
    | `                             )                           |
    | echo `                        echo $(                     |
    | echo abc # a comment with `   echo abc # a comment with ) |
    | `                             )                           |
    | echo `                        echo $(                     |
--More--(14%)    | echo '`'                      echo ')'                    |
    | `                             )                           |
    |___________________________________________________________|

     Because of  these  inconsistent  behaviors,  the  backquoted
     variety  of  command substitution is not recommended for new
     applications that nest command substitutions or  attempt  to
     embed complex scripts.

     If the command substitution consists of a  single  subshell,
     such as:

       $( (command) )

     a portable application must separate the $( and (  into  two
     tokens  (that  is,  separate them with white space). This is
     required to avoid any ambiguities with arithmetic expansion.

  Arithmetic Expansion
     An arithmetic expression enclosed in double parentheses pre-
     ceded  by  a  dollar  sign ( $((arithmetic-expression)) ) is
     replaced by the value of the  arithmetic  expression  within
     the  double  parenthesis.  Arithmetic  expansion  provides a
     mechanism for evaluating an arithmetic expression  and  sub-
     stituting  its value. The format for arithmetic expansion is
     as follows:

       $((expression))

     The expression is treated as if it  were  in  double-quotes,
     except  that  a  double-quote  inside  the expression is not
     treated specially. The  shell  expands  all  tokens  in  the
     expression for parameter expansion, command substitution and

SunOS 5.10          Last change: 29 Jun 2005                   12

User Commands                                              ksh(1)

     quote removal.

     Next, the shell treats this as an arithmetic expression  and
     substitute  the  value  of  the  expression.  The arithmetic
     expression is processed according to the rules of the ISO  C
     with the following exceptions:

         o    Only integer arithmetic is required.

         o    The sizeof() operator and the prefix and postfix ++
--More--(15%)              and -- operators are not required.

         o    Selection, iteration, and jump statements  are  not
              supported.

         o    /usr/bin/ksh  and  /usr/bin/rksh  treat  prefix   0
              through  9  as decimal constants. See the following
              examples:

                    Command         Result in /bin/ksh   Result in /usr/xpg4/bin
/sh
              echo $((010+10))      20                   18
              echo $((019+10))      29                   error
              [ 10 -le $((011)) ]   true                 false

     As an extension, the shell can recognize arithmetic  expres-
     sions beyond those listed. If the expression is invalid, the
     expansion fails and the shell writes a message  to  standard
     error indicating the failure.

     A simple example using arithmetic expansion:

       # repeat a command 100 times
       x=100
       while [ $x -gt 0 ]
       do
           command
           x=$(($x-1))
       done

  Process Substitution
     This feature is available in SunOS and only on  versions  of
     the UNIX operating system that support the /dev/fd directory
     for naming open files. Each command  argument  of  the  form
     <(list)  or  >(list)  runs  process list asynchronously con-
     nected to some file  in  /dev/fd.  The  name  of  this  file

SunOS 5.10          Last change: 29 Jun 2005                   13

User Commands                                              ksh(1)

     becomes  the  argument to the command. If the form with > is
     selected, then writing on this file provides input for list.
     If  <  is used, then the file passed as an argument contains
     the output of the list process. For example:

       paste <(cut -f1 file1) <(cut -f3 file2) | tee >(process1) >(process2)

--More--(16%)     cuts fields 1 and 3 from the files file1 and file2,  respec-
     tively,  pastes  the  results  together, and sends it to the
     processes process1 and process2, as well as putting it  onto
     the  standard  output. The file, which is passed as an argu-
     ment to the command, is a  UNIX  pipe(2)  so  programs  that
     expect to lseek(2) on the file does not work.

  Parameter Substitution
     A parameter is an identifier, one or more digits, or any  of
     the  characters  *,  @,  #,  ?,  -, $, and !.  A variable (a
     parameter denoted by an identifier) has a value and zero  or
     more attributes. variables can be assigned values and attri-
     butes by using the typeset special command.  The  attributes
     supported  by the shell are described later with the typeset
     special command. Exported variables pass values  and  attri-
     butes to the environment.

     The shell supports a one-dimensional array facility. An ele-
     ment  of  an  array variable is referenced by a subscript. A
     subscript is denoted by  a  [,  followed  by  an  arithmetic
     expression,  followed  by a ]. See Arithmetic Evaluation. To
     assign values to an array, use set -A name  value  ....  The
     value  of  all  subscripts must be in the range of 0 through
     4095. Arrays need not be declared. Any reference to a  vari-
     able with a valid subscript is legal and an array is created
     if necessary. Referencing an array without  a  subscript  is
     equivalent  to  referencing the element 0. If an array iden-
     tifier with subscript * or @ is used,  then  the  value  for
     each  of  the  elements is substituted (separated by a field
     separator character).

     The value of a variable can be assigned by writing:

       name=value [ name=value ] ...

     If the integer attribute, -i, is set for name, the value  is
     subject to arithmetic evaluation.

SunOS 5.10          Last change: 29 Jun 2005                   14

User Commands                                              ksh(1)

     Positional parameters, parameters denoted by a  number,  can
     be  assigned  values with the set special command. Parameter
     $0 is set from argument zero when the shell is  invoked.  If
     parameter  is  one  or  more  digits then it is a positional
     parameter. A positional parameter of  more  than  one  digit
     must be enclosed in braces.
--More--(18%)
  Parameter Expansion
     The format for parameter expansion is as follows:

       ${expression}

     where expression consists of all characters until the match-
     ing  }.  Any  }  escaped  by  a backslash or within a quoted
     string, and characters in  embedded  arithmetic  expansions,
     command substitutions and variable expansions, are not exam-
     ined in determining the matching }.

     The simplest form for parameter expansion is:

       ${parameter}

     The value, if any, of parameter is substituted.

     The parameter name or symbol  can  be  enclosed  in  braces,
     which  are  optional  except  for positional parameters with
     more than one digit or when parameter is followed by a char-
     acter  that  could  be  interpreted as part of the name. The
     matching closing brace are determined by counting brace lev-
     els,  skipping over enclosed quoted strings and command sub-
     stitutions.

     If the parameter name or symbol is not enclosed  in  braces,
     the expansion uses the longest valid name whether or not the
     symbol represented by that name exists. When  the  shell  is
     scanning its input to determine the boundaries of a name, it
     is not bound by its knowledge  of  what  names  are  already
     defined.  For example, if F is a defined shell variable, the
     command:

       echo $Fred

SunOS 5.10          Last change: 29 Jun 2005                   15

User Commands                                              ksh(1)

     does not echo the value of $F followed by  red;  it  selects
     the  longest  possible  valid name, Fred, which in this case
     might be unset.

     If a parameter expansion occurs inside double-quotes:

         o    Pathname expansion  is  not  be  performed  on  the
              results of the expansion.
--More--(19%)
         o    Field splitting is not performed on the results  of
              the expansion, with the exception of @.

     In addition, a parameter expansion can be modified by  using
     one  of  the following formats. In each case that a value of
     word is needed (based on the state of  parameter),  word  is
     subjected  to  tilde expansion, parameter expansion, command
     substitution  and  arithmetic  expansion.  If  word  is  not
     needed,  it  is  not expanded. The } character that delimits
     the following parameter expansion  modifications  is  deter-
     mined as described previously in this section and in dquote.
     (For example, ${foo-bar}xyz} would result in  the  expansion
     of  foo  followed by the string xyz} if foo is set, else the
     string barxyz}).

     ${parameter:-word}       Use Default Values. If parameter is
                              unset  or  null,  the  expansion of
                              word is substituted. Otherwise, the
                              value of parameter is substituted.

     ${parameter:=word}       Assign Default Values. If parameter
                              is  unset or null, the expansion of
                              word is assigned to  parameter.  In
                              all   cases,  the  final  value  of
                              parameter  is  substituted.    Only
                              variables,  not  positional parame-
                              ters or special parameters, can  be
                              assigned in this way.

     ${parameter:?[word]}     Indicate Error if Null or Unset. If
                              parameter  is  unset  or  null, the
                              expansion of  word  (or  a  message
                              indicating  it  is unset if word is
                              omitted)  is  written  to  standard
                              error  and  the  shell exits with a
                              non-zero  exit  status.  Otherwise,
                              the  value  of parameter is substi-
                              tuted. An  interactive  shell  need
                              not exit.

SunOS 5.10          Last change: 29 Jun 2005                   16

User Commands                                              ksh(1)

     ${parameter:+[word]}     Use Alternative Value. If parameter
                              is  unset  or null, null is substi-
                              tuted. Otherwise, the expansion  of
--More--(20%)                              word is substituted.

     In the parameter expansions shown  previously,  use  of  the
     colon  in  the format results in a test for a parameter that
     is unset or null. Omission of the colon results  in  a  test
     for a parameter that is only unset. The following two tables
     summarize the effect of the colon:

                        | parameter set and not null | parameter set and null
     ___________________|____________________________|_______________________
     ${parameter:-word} | substitute parameter       | substitute word
     ___________________|____________________________|_______________________
     ${parameter-word}  | substitute parameter       | substitute null
     ___________________|____________________________|_______________________
     ${parameter:=word} | substitute parameter       | assign word
     ___________________|____________________________|_______________________
     ${parameter=word}  | substitute parameter       | substitute parameter
     ___________________|____________________________|_______________________
     ${parameter:?word} | substitute parameter       | error, exit
     ___________________|____________________________|_______________________
     ${parameter?word}  | substitute parameter       | substitute null
     ___________________|____________________________|_______________________
     ${parameter:+word} | substitute word            | substitute null
     ___________________|____________________________|_______________________
     ${parameter+word}  | substitute word            | substitute word

                                         parameter unset
     __________________________________________________________
     ${parameter:-word}            substitute word
     __________________________________________________________
     ${parameter-word}             substitute word
     __________________________________________________________
     ${parameter:=word}            assign word
     __________________________________________________________
     ${parameter=word}             assign null
     __________________________________________________________
     ${parameter:?word}            error, exit
     __________________________________________________________
     ${parameter?word}             error,exit
     __________________________________________________________
     ${parameter:+word}            substitute null
     __________________________________________________________

SunOS 5.10          Last change: 29 Jun 2005                   17

User Commands                                              ksh(1)

     ${parameter+word}             substitute null
--More--(22%)                                 |
                                 |
                                 |
     In all cases shown  with  "s|ubstitute",  the  expression  is
     replaced  with  the  value  |shown.  In  all cases shown with
     "assign", parameter  is  ass|igned  that  value,  which  also
     replaces the expression.    |
                                 |
     ${#parameter}    String Leng|th. The length in characters  of
                      the  value |of parameter. If parameter is *
                      or @, then |all the  positional  parameters,
                      starting   |with    $1,   are   substituted
                      (separated |by a field separator character).
                                 |
                                 |
                                 |
     The following four varieties|of parameter expansion  provide
     for  substring  processing. |In  each case, pattern matching
     notation (see patmat), rathe|r than regular expression  nota-
     tion, is used to evaluate th|e patterns. If parameter is * or
     @, then all the positional p|arameters, starting with $1, are
     substituted  (separated  by |a  field  separator character).
     Enclosing the full parameter| expansion  string  in  double-
     quotes  does  not cause the |following four varieties of pat-
     tern characters to be  quote|d,  whereas  quoting  characters
     within the braces has this e|ffect.
                                 |
     ${parameter%word}     Remove|Smallest  Suffix  Pattern.  The
                           word i|s expanded to produce a pattern.
                           The pa|rameter expansion  then  results
                           in  pa|rameter,  with the smallest por-
                           tion o|f the suffix matched by the pat-
                           tern d|eleted.
                                 |
                                 |
     ${parameter%%word}    Remove  Largest  Suffix  Pattern.  The
                           word is expanded to produce a pattern.
                           The parameter expansion  then  results
                           in parameter, with the largest portion
                           of the suffix matched by  the  pattern
                           deleted.

     ${parameter#word}     Remove Smallest  Prefix  Pattern.  The
                           word is expanded to produce a pattern.
                           The parameter expansion  then  results
                           in  parameter,  with the smallest por-
                           tion of the prefix matched by the pat-
                           tern deleted.
--More--(24%)
SunOS 5.10          Last change: 29 Jun 2005                   18

User Commands                                              ksh(1)

     ${parameter##word}    Remove  Largest  Prefix  Pattern.  The
                           word is expanded to produce a pattern.
                           The parameter expansion  then  results
                           in parameter, with the largest portion
                           of the prefix matched by  the  pattern
                           deleted.

     Examples:

     ${parameter:-word}

     In this example, ls is executed only if x is null or  unset.
     (The  $(ls)  command  substitution  notation is explained in
     Command Substitution above.)

       ${x:-$(ls)}

     ${parameter:=word}

       unset X
       echo ${X:=abc}
       abc

     ${parameter:?word}

       unset posix
       echo ${posix:?}
       sh: posix: parameter null or not set

     ${parameter:+word}

       set a b c
       echo ${3:+posix}
       posix

     ${#parameter}

       HOME=/usr/posix
       echo ${#HOME}
       10

SunOS 5.10          Last change: 29 Jun 2005                   19

--More--(25%)User Commands                                              ksh(1)

     ${parameter%word}

       x=file.c
       echo ${x%.c}.o
       file.o

     ${parameter%%word}

       x=posix/src/std
       echo ${x%%/*}
       posix

     ${parameter#word}

       x=$HOME/src/cmd
       echo ${x#$HOME}
       /src/cmd

     ${parameter##word}

       x=/one/two/three
       echo ${x##*/}
       three

  Parameters Set by Shell
     The following parameters are automatically set by the shell:

     #          The number of positional parameters in decimal.

     -          Flags supplied to the shell on invocation  or  by
                the set command.

     ?          The decimal value returned by the  last  executed
                command.

     $          The process number of this shell.

     _          Initially, the value of _ is an absolute pathname
                of  the  shell or script being executed as passed
                in the environment. Subsequently it  is  assigned
                the  last  argument of the previous command. This

SunOS 5.10          Last change: 29 Jun 2005                   20

User Commands                                              ksh(1)

--More--(26%)                parameter is not set for commands which are asyn-
                chronous. This parameter is also used to hold the
                name of the matching MAIL file when checking  for
                mail.

     !          The process number of the last background command
                invoked.

     ERRNO      The value of errno as set by  the  most  recently
                failed  system  call. This value is system depen-
                dent and is intended for debugging purposes.

     LINENO     The line number of the current  line  within  the
                script or function being executed.

     OLDPWD     The previous working directory set by the cd com-
                mand.

     OPTARG     The value of the last option  argument  processed
                by the getopts special command.

     OPTIND     The index of the last option  argument  processed
                by the getopts special command.

     PPID       The process number of the parent of the shell.

     PWD        The present working directory set by the cd  com-
                mand.

     RANDOM     Each time this variable is referenced,  a  random
                integer,  uniformly  distributed  between  0  and
                32767,  is  generated.  The  sequence  of  random
                numbers can be initialized by assigning a numeric
                value to RANDOM.

     REPLY      This variable is set by the select statement  and
                by the read special command when no arguments are
                supplied.

     SECONDS    Each time this variable is referenced, the number
                of seconds since shell invocation is returned. If

SunOS 5.10          Last change: 29 Jun 2005                   21

User Commands                                              ksh(1)

                this variable is assigned a value, then the value
                returned  upon  reference  is  the value that was
--More--(27%)                assigned plus the number  of  seconds  since  the
                assignment.

  Variables Used by Shell
     The following variables are used by the shell:

     CDPATH         The search path for the cd command.

     COLUMNS        If this variable is set, the value is used to
                    define  the  width of the edit window for the
                    shell edit  modes  and  for  printing  select
                    lists.

     EDITOR         If the value of this variable ends in  emacs,
                    gmacs,  or  vi and the VISUAL variable is not
                    set, then the corresponding option is  turned
                    on. See the set special command.

     ENV            This variable, when and only when an interac-
                    tive shell is invoked, is subjected to param-
                    eter expansion by the shell and the resulting
                    value  is  used  as a pathname of a file con-
                    taining shell commands   to  execute  in  the
                    current  environment.  The  file  need not be
                    executable. If the expanded value of  ENV  is
                    not  an  absolute  pathname,  the results are
                    unspecified. ENV is  ignored  if  the  user's
                    real  and  effective  user  IDs  or  real and
                    effective group IDs are different.

                    This variable can be used to set aliases  and
                    other  items  local  to  the  invocation of a
                    shell. The file referred to  by  ENV  differs
                    from $HOME/.profile in that .profile is typi-
                    cally executed at  session  startup,  whereas
                    the  ENV file is executed at the beginning of
                    each  shell  invocation.  The  ENV  value  is
                    interpreted  in  a  manner  similar  to a dot
                    script, in that the commands are executed  in
                    the current environment and the file needs to
                    be readable,  but  not  executable.  However,
                    unlike dot scripts, no PATH searching is per-
                    formed. This is used as a guard against  Tro-
                    jan Horse security breaches.

SunOS 5.10          Last change: 29 Jun 2005                   22

User Commands                                              ksh(1)
--More--(28%)
     FCEDIT         The default editor name for the fc command.

     FPATH          The search path for function definitions.  By
                    default,  the  FPATH directories are searched
                    after the PATH  variable.  If  an  executable
                    file  is  found, then it is read and executed
                    in the current environment. FPATH is searched
                    before  PATH  when  a  function  with  the -u
                    attribute is  referenced.  The  preset  alias
                    autoload causes a function with the -u attri-
                    bute to be created.

     HISTFILE       If this variable is set  when  the  shell  is
                    invoked,  then  the  value is the pathname of
                    the file that is used to  store  the  command
                    history. See Command re-entry.

     HISTSIZE       If this variable is set  when  the  shell  is
                    invoked,   then   the  number  of  previously
                    entered commands that are accessible by  this
                    shell  is  greater  than  or  equal  to  this
                    number. The default is 128.

     HOME           The default argument (home directory) for the
                    cd command.

     IFS            Internal field  separators,  normally  space,
                    tab,  and  new-line that are used to separate
                    command words which result  from  command  or
                    parameter  substitution  and  for  separating
                    words with the  special  command  read.   The
                    first  character  of the IFS variable is used
                    to separate arguments for  the  $*  substitu-
                    tion. See Quoting.

     LANG           Provide a default value for the  internation-
                    alization  variables  that are unset or null.
                    If any of the internationalization  variables
                    contains  an  invalid  setting,  the  utility
                    behaves as if none of the variables had  been
                    defined.

     LC_ALL         This variable provides a  default  value  for
                    the LC_* variables.

SunOS 5.10          Last change: 29 Jun 2005                   23

--More--(30%)User Commands                                              ksh(1)

     LC_COLLATE     This  variable  determines  the  behavior  of
                    range  expressions,  equivalence  classes and
                    multi-byte   character   collating   elements
                    within pattern matching.

     LC_CTYPE       Determines how the shell handles  characters.
                    When  LC_CTYPE  is  set to a valid value, the
                    shell  can  display  and  handle   text   and
                    filenames  containing  valid  characters  for
                    that locale. If LC_CTYPE (see environ(5))  is
                    not  set  in the environment, the operational
                    behavior of the shell is  determined  by  the
                    value  of  the  LANG environment variable. If
                    LC_ALL is set, its contents are used to over-
                    ride  both  the LANG and the other LC_* vari-
                    ables.

     LC_MESSAGES    This  variable  determines  the  language  in
                    which messages should be written.

     LINENO         This variable  is  set  by  the  shell  to  a
                    decimal   number   representing  the  current
                    sequential  line  number  (numbered  starting
                    with 1) within a script or function before it
                    executes each command. If the user unsets  or
                    resets LINENO, the variable can lose its spe-
                    cial meaning for the life of  the  shell.  If
                    the shell is not currently executing a script
                    or function, the value of LINENO is  unspeci-
                    fied.

     LINES          If this variable is set, the value is used to
                    determine  the  column  length  for  printing
                    select lists. Select lists  print  vertically
                    until  about  two-thirds  of  LINES lines are
                    filled.

     MAIL           If this variable is set to the name of a mail
                    file  and  the  MAILPATH variable is not set,
                    then the shell informs the user of arrival of
                    mail in the specified file.

     MAILCHECK      This  variable  specifies   how   often   (in
                    seconds)  the shell checks for changes in the
                    modification time of any of the files  speci-
                    fied  by  the MAILPATH or MAIL variables. The
--More--(31%)
SunOS 5.10          Last change: 29 Jun 2005                   24

User Commands                                              ksh(1)

                    default value is 600 seconds. When  the  time
                    has  elapsed  the shell checks before issuing
                    the next prompt.

     MAILPATH       A colon (:) separated list of file names.  If
                    this  variable is set, then the shell informs
                    the user of any modifications to  the  speci-
                    fied files that have occurred within the last
                    MAILCHECK seconds. Each file name can be fol-
                    lowed  by  a ? and a message that is printed.
                    The message undergoes parameter  substitution
                    with  the  variable $_ defined as the name of
                    the file that has changed. The  default  mes-
                    sage is you have mail in $_.

     NLSPATH        Determine the location of message  catalogues
                    for the processing of LC_MESSAGES.

     PATH           The search path for commands. See  Execution.
                    The  user  cannot  change  PATH  if executing
                    under rksh (except in .profile).

     PPID           This variable is set  by  the  shell  to  the
                    decimal   process  ID  of  the  process  that
                    invoked the shell. In a subshell, PPID is set
                    to  the  same  value as that of the parent of
                    the current shell. For  example,  echo  $PPID
                    and  (echo  $PPID)  would  produce  the  same
                    value.

     PS1            The value of this variable  is  expanded  for
                    parameter  substitution to define the primary
                    prompt string which by default is ``$ ''. The
                    character  !  in the primary prompt string is
                    replaced by the command number.  See  Command
                    Re-entry.  Two  successive  occurrences  of !
                    produces a single ! when the prompt string is
                    printed.

     PS2            Secondary prompt string, by default ``> ''.

     PS3            Selection prompt string used within a  select
                    loop, by default ``#? ''.
--More--(32%)
SunOS 5.10          Last change: 29 Jun 2005                   25

User Commands                                              ksh(1)

     PS4            The value of this variable  is  expanded  for
                    parameter substitution and precedes each line
                    of an execution trace. If omitted, the execu-
                    tion trace prompt is ``+ ''.

     PWD            Set by the shell to be an  absolute  pathname
                    of  the current working directory, containing
                    no components of type symbolic link, no  com-
                    ponents  that are dot, and no components that
                    are dot-dot when the shell is initialized. If
                    an  application  sets  or unsets the value of
                    PWD, the behaviors of the cd and  pwd  utili-
                    ties are unspecified

     SHELL          The pathname of the  shell  is  kept  in  the
                    environment.  At  invocation, if the basename
                    of this variable is rsh, rksh, or krsh,  then
                    the shell becomes restricted.

     TMOUT          If set to a  value  greater  than  zero,  the
                    shell  terminates if a command is not entered
                    within the prescribed number of seconds after
                    issuing the PS1 prompt. The shell can be com-
                    piled with a maximum  bound  for  this  value
                    which cannot be exceeded.

     VISUAL         If the value of this variable ends in  emacs,
                    gmacs,  or  vi, then the corresponding option
                    is turned on. See Special Command set.

     The shell gives default values to PATH, PS1, PS2, PS3,  PS4,
     MAILCHECK,  FCEDIT,  TMOUT, and IFS, while HOME, SHELL, ENV,
     and MAIL are not set at all by the shell (although  HOME  is
     set  by  login(1)).  On some systems MAIL and SHELL are also
     set by login.

  Blank Interpretation
     After parameter and command  substitution,  the  results  of
     substitutions are scanned for the field separator characters
     (those found in IFS) and split into distinct arguments where
     such characters are found. Explicit null arguments ( "" ) or
     ('') are retained. Implicit null arguments (those  resulting
     from parameters that have no values) are removed.
--More--(34%)
  File Name Generation

SunOS 5.10          Last change: 29 Jun 2005                   26

User Commands                                              ksh(1)

     Following substitution, each command word is scanned for the
     characters *, ?, and [ unless the -f option has been set. If
     one of these characters appears, the word is regarded  as  a
     pattern.  The word is replaced with lexicographically sorted
     file names that match the pattern. If no file name is  found
     that matches the pattern, the word is left unchanged. When a
     pattern is used for  file  name  generation,  the  character
     period  (.)  at the start of a file name or immediately fol-
     lowing a /, as well as  the  character  /  itself,  must  be
     matched  explicitly.  A file name beginning with a period is
     not  matched  with  a  pattern  with   the   period   inside
     parentheses.  That  is,  ls .@(r*) would locate a file named
     .restore, but ls @(.r*) would not.  In  other  instances  of
     pattern matching, the / and . are not treated specially.

     *        Matches any string, including the null string.

     ?        Matches any single character.

     [...]    Matches any one of the enclosed characters. A  pair
              of  characters separated by - matches any character
              lexically between the pair, inclusive. If the first
              character following the opening "[" is a "! ", then
              any character not enclosed is matched. A -  can  be
              included  in the character set by putting it as the
              first or last character.

     A pattern-list is a list of one or more  patterns  separated
     from  each  other with a |. Composite patterns can be formed
     with one or more of the following:

     ?(pattern-list)    Optionally matches any one of  the  given
                        patterns.

     *(pattern-list)    Matches zero or more occurrences  of  the
                        given patterns.

     +(pattern-list)    Matches one or more  occurrences  of  the
                        given patterns.

     @(pattern-list)    Matches exactly one  of  the  given  pat-
--More--(35%)                        terns.

SunOS 5.10          Last change: 29 Jun 2005                   27

User Commands                                              ksh(1)

     !(pattern-list)    Matches anything, except one of the given
                        patterns.

  Quoting
     Each of the metacharacters listed  above  (see  Definitions)
     has a special meaning to the shell and causes termination of
     a word unless quoted. A character can be  quoted  (that  is,
     made to stand for itself) by preceding it with a \. The pair
     \NEWLINE is removed. All characters enclosed between a  pair
     of  single quote marks (' ') are quoted. A single quote can-
     not appear within single quotes. Inside double  quote  marks
     (""),  parameter and command substitution occur and \ quotes
     the characters \, `, ", and $. The meaning of $* and  $@  is
     identical  when  not  quoted  or  when  used  as a parameter
     assignment value or as a file name. However, when used as  a
     command argument, $* is equivalent to ``$1d$2d...'', where d
     is the first character of the IFS variable,  whereas  $@  is
     equivalent  to  $1  $2 .... Inside grave quote marks (``), \
     quotes the characters \, ', and $. If the grave quotes occur
     within double quotes, then \ also quotes the character ".

     The special meaning of reserved  words  or  aliases  can  be
     removed  by  quoting any character of the reserved word. The
     recognition of  function  names  or  special  command  names
     listed cannot be altered by quoting them.

  Arithmetic Evaluation
     An ability to perform integer arithmetic  is  provided  with
     the  special  command  let.  Evaluations are performed using
     long arithmetic. Constants are of the form [ base# ] n where
     base   is  a  decimal  number  between  two  and  thirty-six
     representing the arithmetic base and n is a number  in  that
     base. If base is omitted then base 10 is used.

     An arithmetic expression uses the same  syntax,  precedence,
     and  associativity  of expression as the C language. All the
     integral operators, other than ++, -;, ?:, and  ,  are  sup-
     ported. Variables can be referenced by name within an arith-
     metic expression without using  the  parameter  substitution
     syntax.   When  a  variable  is  referenced,  its  value  is
     evaluated as an arithmetic expression.

--More--(37%)     An internal integer representation  of  a  variable  can  be
     specified with the -i option of the typeset special command.
     Arithmetic evaluation is performed  on  the  value  of  each
     assignment  to  a variable with the -i attribute.  If you do
     not specify an arithmetic base, the first assignment to  the
     variable  determines  the arithmetic base. This base is used

SunOS 5.10          Last change: 29 Jun 2005                   28

User Commands                                              ksh(1)

     when parameter substitution occurs.

     Since many of the arithmetic operators require  quoting,  an
     alternative  form  of  the  let command is provided. For any
     command which begins with a ((, all the characters  until  a
     matching  ))  are  treated as a quoted expression. More pre-
     cisely, ((...)) is equivalent to let "...".

  Prompting
     When used interactively, the shell prompts with the  parame-
     ter  expanded  value  of PS1 before reading a command. If at
     any time a new-line is typed and further input is needed  to
     complete  a command, then the secondary prompt (that is, the
     value of PS2) is issued.

  Conditional Expressions
     A conditional expression is used with the [[  compound  com-
     mand  to  test  attributes  of files and to compare strings.
     Word splitting and file name generation are not performed on
     the  words  between  [[ and ]].  Each expression can be con-
     structed from one or more of the following unary  or  binary
     expressions:

     -a file              True, if file exists.

     -b file              True, if file exists  and  is  a  block
                          special file.

     -c file              True, if file exists and is a character
                          special file.

     -d file              True, if file exists and  is  a  direc-
                          tory.

     -e file              True, if file exists.

     -f file              True, if file exists and is an ordinary
--More--(38%)                          file.

     -g file              True, if file exists and has its setgid
                          bit set.

     -h file              True, if file exists and is a  symbolic
                          link.

SunOS 5.10          Last change: 29 Jun 2005                   29

User Commands                                              ksh(1)

     -k file              True, if file exists and has its sticky
                          bit set.

     -n string            True, if length of string is non-zero.

     -o option            True, if option named option is on.

     -p file              True, if file exists and is a fifo spe-
                          cial file or a pipe.

     -r file              True, if file exists and is readable by
                          current process.

     -s file              True,  if  file  exists  and  has  size
                          greater than zero.

     -t fildes            True, if file descriptor number  fildes
                          is  open and associated with a terminal
                          device.

     -u file              True, if file exists and has its setuid
                          bit set.

     -w file              True, if file exists and is writable by
                          current process.

     -x file              True, if file exists and is  executable
                          by  current process. If file exists and
                          is a directory, then the  current  pro-
                          cess  has  permission  to search in the
                          directory.

     -z string            True, if length of string is zero.

     -L file              True, if file exists and is a  symbolic
                          link.
--More--(39%)
     -O file              True, if file exists and  is  owned  by
                          the effective user id of this process.

SunOS 5.10          Last change: 29 Jun 2005                   30

User Commands                                              ksh(1)

     -G file              True, if  file  exists  and  its  group
                          matches  the effective group id of this
                          process.

     -S file              True, if file exists and is a socket.

     file1 -nt file2      True, if file1 exists and is newer than
                          file2.

     file1 -ot file2      True, if file1 exists and is older than
                          file2.

     file1 -ef file2      True, if  file1  and  file2  exist  and
                          refer to the same file.

     string               True if the string string  is  not  the
                          null string.

     string = pattern     True, if string matches pattern.

     string != pattern    True, if string does not match pattern.

     string1 < string2    True, if string1 comes  before  string2
                          based   on   strings   interpreted   as
                          appropriate to the locale  setting  for
                          category LC_COLLATE.

     string1 > string2    True, if string1  comes  after  string2
                          based   on   strings   interpreted   as
                          appropriate to the locale  setting  for
                          category LC_COLLATE.

     exp1 -eq exp2        True, if exp1 is equal to exp2.

     exp1 -ne exp2        True, if exp1 is not equal to exp2.

     exp1 -lt exp2        True, if exp1 is less than exp2.

SunOS 5.10          Last change: 29 Jun 2005                   31

--More--(40%)/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    FECHA_PROC_YYYYMM=$(echo $FECHA_PROC  | cut -c1-6)clear
echo $raya
#   banner "PE Ripley"
    echo "$ASCIIBanner"
    echo $raya
    [[ $debug -eq 1 ]] && echo "DEBUG"

#*******************************************************************************
# Lectura de parámetros en la terminal
#*******************************************************************************
    leerParametros

#*******************************************************************************
# Nombres de los archivos, SANATA
#*******************************************************************************
    # la variable archivo es el nombre de la base, interna o del cliente,
    # y se usa para armar todos los demás nombres de archivos del proceso
    if [[ $BASE = "E" ]]
    then
# el nombre del archivo, sin extensión,  de la base externa
archivo=$NOM_ARCHIVO
archivo=$( echo $NOM_ARCHIVO | sed "s/\..*//" )
if [[ $NOM_ARCHIVO != $archivo ]]
then
mv $NOM_ARCHIVO $archivo
fielse
# un nombre armado con "PERipley" y la fecha del día
# $$$$ no será posible ejecutar dos procesos en el mismo día
# $$$$ se puede agregar un $$ al file name, o la hora
# $$$$ se puede controlar si ya existe un archivo de hoy ...
archivo="PERipley"$FECHA_PROC
NOM_ARCHIVO=$archivo
    fi
# arma los nombres de los archivos del proceso en base al anterior
    archivo_prn=$archivo.prn
    archivo_val=$archivo.val
    archivo_inc=$archivo.inc

#*******************************************************************************
# Proceso histórico: ubica la SANATA que corresponde a la fecha inicial
# de proceso FECHA_INICIO
#    Ejemplos de variables exportadas:
#    DATABASE=/san_ata_2/200412/icdb
#    DATABASE=/san_ata_3/200512/icdb
#    EXTFH=/san_ata_3/200603/extfh.cfg   
INSERT MODE# 
# 
      # 
# 
#    EXTFH=/san_ata_3/200601/extfh.cfg#    EXTFH=/san_ata_3/200603/extfh.cfg
#    EXTFH=/san_ata_3/200601/extfh.cfg
#*******************************************************************************
    if [[ $TIPO_PROC = "H" ]]
    then
FECHA_INICIO_YYYYMM=$(echo $FECHA_INICIO | cut -c1-6 )
sanata=$(grep $FECHA_INICIO_YYYYMM $DATOS/ICSANATA.DAT | cut -c17-17)
echo "sanata para fecha" $FECHA_INICIO_YYYYMM "es" $sanata
if [[ -z "$sanata" ]]
then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"echo $EXTFH
export DATABASE="/san_ata_"$sanata"/"$fecha"/icdb"echo $DATABASE
fi
    fi

#*******************************************************************************
# Extracción
# Produce el archivo prn
#*******************************************************************************
    cd $TEMPORALES
    if [[ $BASE = "I" ]]
    then
echo $raya
echo "EXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT"
# echo "\n$raya\nEXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT\n\n" >> $archivo_log
ejecutar_extraccion
echo "Finalizada la extracción"
# cancela si no extrajo nada
if [[ -n cantRegsExtraidos ]] || [[ cantRegsExtraidos -le 0 ]]
then
echo "Extracción produjo cero registros - cancelando"exit
fi
    else
cp $archivo $archivo_prn
    fi

#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo $raya[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>ls prip*
pripley1.in   pripley1.prn
/d/iccol/desarrollo/macros>co priplety 1.in       y1.in pripley1.in
ksh: cd: bad argument count
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>co pripley1.in pripley1.incp
cp: pripley1.in and pripley1.in are identical
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
#    EXTFH=/san_ata_3/200603/extfh.cfg
#    EXTFH=/san_ata_3/200601/extfh.cfg
#*******************************************************************************
    if [[ $TIPO_PROC = "H" ]]
    then
FECHA_INICIO_YYYYMM=$(echo $FECHA_INICIO | cut -c1-6 )
sanata=$(grep $FECHA_INICIO_YYYYMM $DATOS/ICSANATA.DAT | cut -c17-17)
echo "sanata para fecha" $FECHA_INICIO_YYYYMM "es" $sanata
if [[ -z "$sanata" ]]
then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"echo $EXTFH
export DATABASE="/san_ata_"$sanata"/"$fecha"/icdb"echo $DATABASE
fi
    fi

#*******************************************************************************
# Extracción
# Produce el archivo prn
#*******************************************************************************
    cd $TEMPORALES
    if [[ $BASE = "I" ]]
    then
echo $raya
echo "EXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT"
# echo "\n$raya\nEXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT\n\n" >> $archivo_log
ejecutar_extraccion
echo "Finalizada la extracción"
# cancela si no extrajo nada
if [[ -n cantRegsExtraidos ]] || [[ cantRegsExtraidos -le 0 ]]
then
echo "Extracción produjo cero registros - cancelando"exit
fi
    else
cp $archivo $archivo_prn
    fi

#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo $raya    FECHA_PROC_YYYYMM=$(echo $FECHA_PROC  | cut -c1-6)clear
echo $raya
#   banner "PE Ripley"
    echo "$ASCIIBanner"
    echo $raya
    [[ $debug -eq 1 ]] && echo "DEBUG"

#*******************************************************************************
# Lectura de parámetros en la terminal
#*******************************************************************************
    leerParametros

#*******************************************************************************
# Nombres de los archivos, SANATA
#*******************************************************************************
    # la variable archivo es el nombre de la base, interna o del cliente,
    # y se usa para armar todos los demás nombres de archivos del proceso
    if [[ $BASE = "E" ]]
    then
# el nombre del archivo, sin extensión,  de la base externa
archivo=$NOM_ARCHIVO
archivo=$( echo $NOM_ARCHIVO | sed "s/\..*//" )
# if [[ $NOM_ARCHIVO != $archivo ]]
# then
#   mv $NOM_ARCHIVO $archivo
# fi
    else
# un nombre armado con "PERipley" y la fecha del día
# $$$$ no será posible ejecutar dos procesos en el mismo día
# $$$$ se puede agregar un $$ al file name, o la hora
# $$$$ se puede controlar si ya existe un archivo de hoy ...
archivo="PERipley"$FECHA_PROC
NOM_ARCHIVO=$archivo
    fi
# arma los nombres de los archivos del proceso en base al anterior
    archivo_prn=$archivo.prn
    archivo_val=$archivo.val
    archivo_inc=$archivo.inc

#*******************************************************************************
# Proceso histórico: ubica la SANATA que corresponde a la fecha inicial
# de proceso FECHA_INICIO
#    Ejemplos de variables exportadas:
#    DATABASE=/san_ata_2/200412/icdb
#    DATABASE=/san_ata_3/200512/icdb
#    EXTFH=/san_ata_3/200603/extfh.cfg
#    EXTFH=/san_ata_3/200601/extfh.cfg
    




    



    


#*******************************************************************************# REPLACE 1 CHARcINSERT MODEvo e,  de la base externa#    EXTFH=/san_ata_3/200601/extfh.cfg
#*******************************************************************************
    if [[ $TIPO_PROC = "H" ]]
    then
FECHA_INICIO_YYYYMM=$(echo $FECHA_INICIO | cut -c1-6 )
sanata=$(grep $FECHA_INICIO_YYYYMM $DATOS/ICSANATA.DAT | cut -c17-17)
echo "sanata para fecha" $FECHA_INICIO_YYYYMM "es" $sanata
if [[ -z "$sanata" ]]
then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"echo $EXTFH
export DATABASE="/san_ata_"$sanata"/"$fecha"/icdb"echo $DATABASE
fi
    fi

#*******************************************************************************
# Extracción
# Produce el archivo prn
#*******************************************************************************
    cd $TEMPORALES
    if [[ $BASE = "I" ]]
    then
echo $raya
echo "EXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT"
# echo "\n$raya\nEXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT\n\n" >> $archivo_log
ejecutar_extraccion
echo "Finalizada la extracción"
# cancela si no extrajo nada
if [[ -n cantRegsExtraidos ]] || [[ cantRegsExtraidos -le 0 ]]
then
echo "Extracción produjo cero registros - cancelando"exit
fi
    else
cp $archivo $archivo_prn
    fi

#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo $raya
    echo "PESVNO: validación de IDs"/ejecutar_extraccion?    echo "${i}Archivo: "$NOM_ARCHIVOprint -n "${i}Base: "$BASE
    if [[ $BASE = "E" ]]
    then
echo "${s}provista por el cliente"
print -n "${i}Estructura: "$TIPO_ARCHIVO
[[ $TIPO_ARCHIVO = "1" ]] && echo "${s}1-11"
[[ $TIPO_ARCHIVO = "2" ]] && echo "${s}1-11-45"
    else
echo "${s}extraída de datos internos"
print -n "${i}Criterio de extracción: "$TIPO_EXTRACT
[[ $TIPO_EXTRACT = "N" ]] && echo "${s}por NIT "$ID_EXTRACT
[[ $TIPO_EXTRACT = "C" ]] && echo "${s}por cod suscriptor "$ID_EXTRACT
    fi
print -n "${i}Tipo de proceso: "$TIPO_PROC
    if [[ $TIPO_PROC = "H" ]]
    then
echo "${s}histórico, desde: "$FECHA_INICIO
    else
echo "${s}actual"
    fi
}

ejecutar_extraccion() {
#***********************************************************************
# Extrae registros por suscriptor del archivo ICMCRECOPY.DAT en el prn
#***********************************************************************
    # el directorio del archivo cambia según el ambiente
    P_MAQUINA=$(hostname)
    if [[ $P_MAQUINA = $P_SERVER_DEV ]]
    then
echo "Máquina de desarrollo:" $P_MAQUINA
ICMCRECOPY='/despeciales/ICMCRECOPY.DAT'
    else
# echo "Máquina de producción:" $P_MAQUINA
ICMCRECOPY='$ESPECIALES/ctlc/ICMCRECOPY.DAT'
    fi
# extrae tipo y número de id por NIT del suscriptor, elimina repeticiones
    [[ -s $archivo_prn ]] && rm $archivo_prn
    echo "El archivo de salida es $archivo_prn"
    echo "El archivo de input es "$ICMCRECOPY
    if [[ TIPO_EXTRAC = "N" ]]
    then # extracción por NIT
grepRegex="^.........*"$ID_EXTRACT"..$"
# grepRegex="^A......[14].*"$ID_EXTRACT".P$"
    else # extracción por cod suscriptor
grepRegex="^."$ID_EXTRACT"..*..$"
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"
    fi# $$$$ DEBUG: regex que extrae TODOS los registros
[[ $debug = 1 ]] && grepRegex='.*'
echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
# cuenta los registros extraídos
cantRegsExtraidos=$(wc -l < $archivo_prn)
echo "Registros extraídos: "$cantRegsExtraidos
TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************



    INSERT MODEmaestro /then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"echo $EXTFH
export DATABASE="/san_ata_"$sanata"/"$fecha"/icdb"echo $DATABASE
fi
    fi

#*******************************************************************************
# Extracción
# Produce el archivo prn
#*******************************************************************************
    cd $TEMPORALES
    if [[ $BASE = "I" ]]
    then
echo $raya
echo "EXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT"
# echo "\n$raya\nEXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT\n\n" >> $archivo_log
ejecutar_extraccion
echo "Finalizada la extracción"
# cancela si no extrajo nada
if [[ -n cantRegsExtraidos ]] || [[ cantRegsExtraidos -le 0 ]]
then
echo "Extracción produjo cero registros - cancelando"exit
fi
    else
cp $archivo $archivo_prn
    fi

#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo $raya
    echo "PESVNO: validación de IDs"
    sleep 1
    # echo "\n$raya\nPESVNO:\n\n" >> $archivo_log
    [[ -s $archivo_val ]] && rm $archivo_val
    [[ -s $archivo_inc ]] && rm $archivo_inc
    ejecutar_validacion
    [[ $cancelado = "1" ]] && exit# control: si no hay un archivo .val se cancela el proceso    if [[ $TIPO_PROC = "H" ]]then
echo "${s}histórico, desde: "$FECHA_INICIO
    else
echo "${s}actual"
    fi
}

ejecutar_extraccion() {
#***********************************************************************
# Extrae registros por suscriptor del archivo ICMCRECOPY.DAT en el prn
#***********************************************************************
    # el directorio del archivo maestro cambia según el ambiente
    P_MAQUINA=$(hostname)
    if [[ $P_MAQUINA = $P_SERVER_DEV ]]
    then
echo "Máquina de desarrollo:" $P_MAQUINA
ICMCRECOPY='/despeciales/ICMCRECOPY.DAT'
    else
# echo "Máquina de producción:" $P_MAQUINA
ICMCRECOPY='$ESPECIALES/ctlc/ICMCRECOPY.DAT'
    fi
# extrae tipo y número de id por NIT del suscriptor, elimina repeticiones
    [[ -s $archivo_prn ]] && rm $archivo_prn
    echo "El archivo de salida es $archivo_prn"
    echo "El archivo de input es "$ICMCRECOPY
    if [[ TIPO_EXTRAC = "N" ]]
    then # extracción por NIT
grepRegex="^.........*"$ID_EXTRACT"..$"
# grepRegex="^A......[14].*"$ID_EXTRACT".P$"
    else # extracción por cod suscriptor
grepRegex="^."$ID_EXTRACT"..*..$"
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"
    fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"echo $EXTFH
export DATABASE="/san_ata_"$sanata"/"$fecha"/icdb"echo $DATABASE
fi
    fi

#*******************************************************************************
# Extracción
# Produce el archivo prn
#*******************************************************************************
    cd $TEMPORALES
    if [[ $BASE = "I" ]]
    then
echo $raya
echo "EXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT"
# echo "\n$raya\nEXTRACCIÓN: $TIPO_EXTRACT $ID_EXTRACT\n\n" >> $archivo_log
ejecutar_extraccion
echo "Finalizada la extracción"
# cancela si no extrajo nada
if [[ -n cantRegsExtraidos ]] || [[ cantRegsExtraidos -le 0 ]]
then
echo "Extracción produjo cero registros - cancelando"exit
fi
    else
cp $archivo $archivo_prn
    fi

#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo $raya
    echo "PESVNO: validación de IDs"
    sleep 1
    # echo "\n$raya\nPESVNO:\n\n" >> $archivo_log
    [[ -s $archivo_val ]] && rm $archivo_val
    [[ -s $archivo_inc ]] && rm $archivo_inc
    ejecutar_validacion
    [[ $cancelado = "1" ]] && exit# control: si no hay un archivo .val se cancela el proceso




    



    OPEN MODE# copia el archila base externa como .prn (a menos qyueue ya tenga ese nombre)
OPEN MODEif [[ $NOM_ARCHIVO = $archivo_prn ]]INSERT MODE!
OPEN MODEthen
    cp $archivo $archivo_prn
OPEN MODEfifi    cp $$CHANGE MODENOM_ARCHIVO/Address search hit BOTTOM without matching pattern?ejecutar_validacion[[ $cancelado = "1" ]] && exit# control: si no hay un archivo .val se cancela el procesoif [[ ! -s $archivo_val ]]thenecho "No hay un archivo de registros validados - PROCESO CANCELADO"exitfi#*******************************************************************************# SCOTBATCH: cálculo de scores/ejecutar_validacion?    fi
# extrae tipo y número de id por NIT del suscriptor, elimina repeticiones
    [[ -s $archivo_prn ]] && rm $archivo_prn
    echo "El archivo de salida es $archivo_prn"
    echo "El archivo de input es "$ICMCRECOPY
    if [[ TIPO_EXTRAC = "N" ]]
    then # extracción por NIT
grepRegex="^.........*"$ID_EXTRACT"..$"
# grepRegex="^A......[14].*"$ID_EXTRACT".P$"
    else # extracción por cod suscriptor
grepRegex="^."$ID_EXTRACT"..*..$"
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"
    fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    fi

echo PESVNO $archivo_prn $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $archivo_prn $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros# grepRegex="^A"$ID_EXTRACT"[14].*.P$"grepRegex="^."$ID_EXTRACT"..*..$"    else # extracción por cod suscriptor




    




    




    OPEN MODEelse
 




PESVNO_INPUT=${archivo}"VALI.prn"PESVNO_INPUT=$o$CHANGE MODE.prnREPLACE 1 CHAR_PESVNO_INPUT/archivo_prn/PESVNO_INPUTarchivo_prn $archivo_val $archivo_inc 10 2PESVNO_INPUT/PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log//
#*******************************************************************************
# Nombres de los archivos, SANATA
#*******************************************************************************
    # la variable archivo es el nombre de la base, interna o del cliente,
    # y se usa para armar todos los demás nombres de archivos del proceso
    if [[ $BASE = "E" ]]
    then
# el nombre del archivo, sin extensión,  de la base externa
archivo=$( echo $NOM_ARCHIVO | sed "s/\..*//" )
# if [[ $NOM_ARCHIVO != $archivo ]]
# then
#   mv $NOM_ARCHIVO $archivo
# fi
    else
# un nombre armado con "PERipley" y la fecha del día
# $$$$ no será posible ejecutar dos procesos en el mismo día
# $$$$ se puede agregar un $$ al file name, o la hora
# $$$$ se puede controlar si ya existe un archivo de hoy ...
archivo="PERipley"$FECHA_PROC
NOM_ARCHIVO=$archivo
    fi
# arma los nombres de los archivos del proceso en base al anterior
    archivo_prn=$archivo.prn
    archivo_val=$archivo.val
    archivo_inc=$archivo.inc

#*******************************************************************************
# Proceso histórico: ubica la SANATA que corresponde a la fecha inicial
# de proceso FECHA_INICIO
#    Ejemplos de variables exportadas:
#    DATABASE=/san_ata_2/200412/icdb
#    DATABASE=/san_ata_3/200512/icdb
#    EXTFH=/san_ata_3/200603/extfh.cfg
#    EXTFH=/san_ata_3/200601/extfh.cfg
#*******************************************************************************
    if [[ $TIPO_PROC = "H" ]]
    then
FECHA_INICIO_YYYYMM=$(echo $FECHA_INICIO | cut -c1-6 )
sanata=$(grep $FECHA_INICIO_YYYYMM $DATOS/ICSANATA.DAT | cut -c17-17)
echo "sanata para fecha" $FECHA_INICIO_YYYYMM "es" $sanata
if [[ -z "$sanata" ]]
then
echo " "
echo "No se encontró sanata para la fecha $FECHA_INICIO_YYYYMM"echo "Digite san_ata para fecha historica $FECHA_INICIO_YYYYMM ---> \c"read sanata
echo " "
export EXTFH="/san_ata_"$sanata"/"$fecha"/extfh.cfg"}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    registroExtra=0
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
registroExtra=1
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    head -10 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc + $registroExtra) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do






$    CHANGE MODEtail -20
    
) ]]






    


readBASE# I interna, C cliente

    



if [[ $BASE = "E" ]]
    


    









    



    :w"sh-PE-Ripley" 759 lines, 26926 characters [1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>/^shsh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.in;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.in
 
            ARCHIVO:pripley1.in
            ARCHIVO:pripley1.prn
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1VALI.prn pripley1.val pripley1.inc 10 2
wc: cannot open /dicregis/pva/temporales/pripley1VALI.prn
sort: can't stat /dicregis/pva/temporales/pripley1VALI.prn: No such file or directory

real    0m0.06s
user    0m0.01s
sys     0m0.01s
sh-PE-Ripley[20]: pripley1.val: cannot open
sh-PE-Ripley[21]: pripley1.inc: cannot open
PESVNO - registros válidos:  inconsistentes:  total: 124732
!!........EL ORDEN DE LOS PARAMETROS ES ........!!
!!..ENTRADA CORRECTOS INCORRECTOS TARIFA BLOQUES.!!
REGISTROS RECIBIDOS ORIGINALMENTE:
ARCHIVO: pripley1VALI.prn              
ERROR ORDENANDO UNICOS pripley1VALI.prn              

Inicio de Programa:  2014/06/03 17:00:26
Fin de Programa:     2014/06/03 17:00:26

expr: syntax error
expr: syntax error
 
----------------------------------------------------------------------
Las cantidades de registros no cuadran: proceso cancelado
----------------------------------------------------------------------
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]/-test    sleep 1# echo "\n$raya\nSCOTBATCH:\n\n" >> $archivo_log
    # parámetros para el programa:
    formato="VAL"
    scoring="067"    # ACIERTA+echo SCOTBATCH $FECHA_PROC_YYYYMM $scoring $formato $archivo_val
    $NOHUP x SCOTBATCH $FECHA_PROC_YYYYMM $scoring $formato $archivo_val >> $archivo.log 2>>$archivo.log
    tail -25 $archivo.log

#*******************************************************************************
# Ejecución del programa iceprerip01
#*******************************************************************************
    echo $raya
    echo "ICEPRERIP01: datos para Ripley"
    echo " "
# Los parámetros son:
#    archivo de entrada de validados
#    archivo de entrada de inconsistencias
#    estructura del archivo ????
#    tipo de proceso ????
#    fecha del periodo
    sleep 1
    $NOHUP x iceprerip01-test $archivo_val $archivo_inc 2 A $FECHA_PROC >> $archivo.log 2>>$archivo.log
    tail -20 $archivo.log

#*******************************************************************************
# Nombres de los archivos
#*******************************************************************************
    # muestra los nombres de los archivos del proceso
    echo $raya
    echo "ARCHIVOS:"
    echo " "
    # echo "\n$raya\nICEPRERIP01:\n\n" >> $archivo_log
    ls -l *$archivo*
    echo " "

#*******************************************************************************
# Finalmente
#*******************************************************************************
    horaFin=$(date '+%H:%M:%S')
    echo " "
    echo $raya
    echo "fin del proceso "$0
    echo "Iniciado: "$horaInicio  "finalizado: "$horaFin
    echo $raya
    exit

#*******************************************************************************    else # extracción por cod suscriptorgrepRegex="^."$ID_EXTRACT"..*..$"
# grepRegex="^A"$ID_EXTRACT"[14].*.P$"
    fi
# $$$$ DEBUG: regex que extrae TODOS los registros
    [[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv  $PESVNO_INPUT $archivo_prn
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}[IAPPEND MODE grabando}
APPEND MODE    # un archivo ...VALI.prn para la validacconel registro de control adelanteconINSERT MODE 
    

    


mvleerParametros() {#*******************************************************************************# Interacción con el operador para cargar/editar el set de parámetros   :w"sh-PE-Ripley" 760 lines, 26991 characters [1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgsh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1VALI.prn pripley1.val pripley1.inc 10 2
wc: cannot open /dicregis/pva/temporales/pripley1VALI.prn
sort: can't stat /dicregis/pva/temporales/pripley1VALI.prn: No such file or directory

real    0m0.05s
user    0m0.01s
sys     0m0.01s
sh-PE-Ripley[21]: pripley1.val: cannot open
sh-PE-Ripley[22]: pripley1.inc: cannot open
PESVNO - registros válidos:  inconsistentes:  total: 124733
!!........EL ORDEN DE LOS PARAMETROS ES ........!!
!!..ENTRADA CORRECTOS INCORRECTOS TARIFA BLOQUES.!!
REGISTROS RECIBIDOS ORIGINALMENTE:
ARCHIVO: pripley1VALI.prn              
ERROR ORDENANDO UNICOS pripley1VALI.prn              

Inicio de Programa:  2014/06/03 17:12:36
Fin de Programa:     2014/06/03 17:12:36

expr: syntax error
expr: syntax error
 
----------------------------------------------------------------------
Las cantidades de registros no cuadran: proceso cancelado
----------------------------------------------------------------------
/d/iccol/desarrollo/macros>ls -l $TEMPORALES/priple*
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 16:03 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2033 Jun  3 16:03 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 /dicregis/pva/temporales/pripley1.in
-rw-rw-r--   1 ichdd    icdatacr     316 Jun  3 17:12 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr   28485 Jun  3 16:24 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621562 Jun  3 17:12 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 16:24 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:28 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 /dicregis/pva/temporales/pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 /dicregis/pva/temporales/pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621562 Jun  3 17:07 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 /dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv $PESVNO_INPUT $archivo_prn
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgls -l $TEMPORALES/priple*ls -l priple*            
-rw-rw-r--   1 icjlud   icdatacr 1746220 Jun  3 16:26 pripley1.in
-rw-rw-r--   1 icjlud   icdatacr 1746220 Jun  3 13:46 pripley1.prn
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv $PESVNO_INPUT $archivo_prn
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
     [1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>echo ar  $archivo

/d/iccol/desarrollo/macros>archivo="  _p         echo $archivo_prn
pripley11
/d/iccol/desarrollo/macros>archivo_prn=pripley1- .prn" 
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>archivo _prn=pripley1.prnecho $archivo _prn       
pripley1.prn
/d/iccol/desarrollo/macros>archivo="pripley1
> ^C
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>archivo="pripley1archivo="pripley1 
/d/iccol/desarrollo/macros>PESVNO_INPUT=${archivo}"VALI.prn"
/d/iccol/desarrollo/macros>echo PESVNO_INPUT^[  /d/iccol/desarrollo/macros>echo PESVNO _INPUT$PESVNO _INPUT
pripley1VALI.prn
/d/iccol/desarrollo/macros>cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
/d/iccol/desarrollo/macros>ls -l $PESVNO_INPUT
-rw-rw-r--   1 icjlud   icdatacr 1746244 Jun  3 17:17 pripley1VALI.prn
/d/iccol/desarrollo/macros>x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 ^[  /d/iccol/desarrollo/macros>ivo _val $archivo _inc 10 2                         <archivo..x PESVNO $PESVNO _INPUT $archivo.val $archivo.inc 1>/d/iccol/desarrollo/macros>
!!........EL ORDEN DE LOS PARAMETROS ES ........!!
!!..ENTRADA CORRECTOS INCORRECTOS TARIFA BLOQUES.!!
REGISTROS RECIBIDOS ORIGINALMENTE:
wc: cannot open /dicregis/pva/temporales/pripley1VALI.prn
ARCHIVO: pripley1VALI.prn              
sort: can't stat /dicregis/pva/temporales/pripley1VALI.prn: No such file or directory
ERROR ORDENANDO UNICOS pripley1VALI.prn              

real    0m0.06s
user    0m0.01s
sys     0m0.01s

Inicio de Programa:  2014/06/03 17:18:45
Fin de Programa:     2014/06/03 17:18:45

/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
rm $archivo_prn
mv $PESVNO_INPUT $archivo_prn
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros"sh-PE-Ripley" line 475 of 760 --62%-- 
#*******************************************************************************
#   carga los valores del archivo .parm:w"sh-PE-Ripley" 758 lines, 26941 characters [1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgx PESVNO $PESVNO _INPUT $archivo.val $archivo.inc 1>/d/iccol/desarrollo/macros>ls -l $PESVNO _INPUT                                /d/iccol/desarrollo/macros>cat $DATOS/REGPESVNO.VALI $archivo _prn >| $PESVNO _>/d/iccol/desarrollo/macros>echo $PESVNO _INPUT                                 /d/iccol/desarrollo/macros>PESVNO _INPUT=${archivo}"VALI.prn"/d/iccol/desarrollo/macros>archivo=pripley1                 /d/iccol/desarrollo/macros>archivo="pripley1echo $archivo _prnarchivo _prn=pripley1.prnecho $archivo _prn       echo $archivo    fg           
/d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley1 ¨*  *
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 16:03 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2033 Jun  3 16:03 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 /dicregis/pva/temporales/pripley1.in
-rw-rw-r--   1 ichdd    icdatacr     316 Jun  3 17:12 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr   28485 Jun  3 16:24 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621562 Jun  3 17:12 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 16:24 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:28 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 /dicregis/pva/temporales/pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 /dicregis/pva/temporales/pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621562 Jun  3 17:07 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 /dicregis/pva/temporales/pripley11.vre
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley*fg                        x PESVNO $PESVNO _INPUT $archivo.val $archivo.inc 1>/d/iccol/desarrollo/macros>ls -l $PESVNO _INPUT                                /d/iccol/desarrollo/macros>cat $DATOS/REGPESVNO.VALI $archivo _prn >| $PESVNO _>/d/iccol/desarrollo/macros>echo $PESVNO _INPUT                                 /d/iccol/desarrollo/macros>PESVNO _INPUT=${archivo}"VALI.prn"/d/iccol/desarrollo/macros>                                 /d/iccol/desarrollo/macros>/^shsh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1VALI.prn pripley1.val pripley1.inc 10 2

real    0m9.41s
user    0m5.88s
sys     0m3.02s
PESVNO - registros válidos: 122770  inconsistentes: 1960  total: 124733
REGISTROS NO EXISTEN   BDIIREGI :0000002
REGISTROS NO EXISTEN   BDIIDIAN :0000001
TIPO IDENTIFICACION INVALIDO    :0000000
===================================
ACTUALIZANDO REGIS PARA FACTURACION
===================================
FECHA : 20140603
HORA  : 1722
===================================
ABRIENDO ARCHIVO :$DATOS/LOGPESVNO.DAT                  - 00
RESULTADO OPERACION :$DATOS/LOGPESVNO.DAT                  - 00
Graba Tipo 5    ==> 000000122770
Graba Tipo 6    ==> 000000001957
Graba Tipo 7    ==> 000000000003
Graba Tipo 5 PJ ==> 000000003034
TRANSAC-STATUS-WK: OK

Inicio de Programa:  2014/06/03 17:22:46
Fin de Programa:     2014/06/03 17:22:56

 
----------------------------------------------------------------------
Las cantidades de registros no cuadran: proceso cancelado
----------------------------------------------------------------------
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm/no cuadran[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgsh-PE-Ripleyls -l $TEMPORALES/pripley*
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 16:03 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2033 Jun  3 16:03 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 /dicregis/pva/temporales/pripley1.in
-rw-rw-r--   1 icjlud   icdatacr  301840 Jun  3 17:22 /dicregis/pva/temporales/pripley1.inc
-rw-rw-r--   1 ichdd    icdatacr    1286 Jun  3 17:22 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr   28485 Jun  3 16:24 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621562 Jun  3 17:12 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 16:24 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icjlud   icdatacr 12989915 Jun  3 17:22 /dicregis/pva/temporales/pripley1.val
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 17:22 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 /dicregis/pva/temporales/pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 /dicregis/pva/temporales/pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621562 Jun  3 17:07 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 /dicregis/pva/temporales/pripley11.vre
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 17:22 /dicregis/pva/temporales/pripley1VALI.prn
/d/iccol/desarrollo/macros>view /dicregis/pva/temporales/pripley1.prn
"/dicregis/pva/temporales/pripley1.prn" [Read only] 124733 lines, 1621562 characters VALIDAR=NO^M
VALIDAR=NO^M
VALIDAR=NO^M
100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914"/dicregis/pva/temporales/pripley1.prn" [Read only] 124733 lines, 1621562 characters100000058754
100000059035
100000060120"/dicregis/pva/temporales/pripley1.prn" File is read only:w!"/dicregis/pva/temporales/pripley1.prn" 124730 lines, 1621490 characters /d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>view /dicregis/pva/temporales/pripley1.prn/d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley*                /d/iccol/desarrollo/macros>fg                        sh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley1.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley1.prn
 
            ARCHIVO:pripley1.prn
            ARCHIVO:
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley1.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley1.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley1.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley1.prn
PESVNO pripley1VALI.prn pripley1.val pripley1.inc 10 2

real    0m8.97s
user    0m5.86s
sys     0m3.03s
PESVNO - registros válidos: 122770  inconsistentes: 1960  total: 124730
REGISTROS NO EXISTEN   BDIIREGI :0000002
REGISTROS NO EXISTEN   BDIIDIAN :0000001
TIPO IDENTIFICACION INVALIDO    :0000000
===================================
ACTUALIZANDO REGIS PARA FACTURACION
===================================
FECHA : 20140603
HORA  : 1727
===================================
ABRIENDO ARCHIVO :$DATOS/LOGPESVNO.DAT                  - 00
RESULTADO OPERACION :$DATOS/LOGPESVNO.DAT                  - 00
Graba Tipo 5    ==> 000000122770
Graba Tipo 6    ==> 000000001957
Graba Tipo 7    ==> 000000000003
Graba Tipo 5 PJ ==> 000000003034
TRANSAC-STATUS-WK: OK

Inicio de Programa:  2014/06/03 17:26:55
Fin de Programa:     2014/06/03 17:27:04

----------------------------------------------------------------------
SCOTBATCH: cálculo de scores
 
SCOTBATCH 201406 067 VAL pripley1.val
Tipo score: ACIERTA+   
                                             
Score formato validado   
                                             
PROGRAMA ARRANCA CON REINICIO AUTOMATICO
REINICIO ULT-TIP-ID: 1
         ULT-NUM-ID: 00000218356
SE LEYERON REINICIANDO: 0000211
TIP-ID-ENTR: 1
NUM-ID-ENTR: 00000218356
===== CONTADORES AL REINICIO====
Clientes con ACIERTA+  mayor a ceros: 0000211
================================
===== CONTADORES FINALES    ====
Clientes con ACIERTA+  mayor a ceros: 0119669
================================
SE LEYERON EN TOTAL: 0122770

real    10m42.25s
user    9m28.58s
sys     0m46.71s

Inicio de Programa:  2014/06/03 17:27:05
Fin de Programa:     2014/06/03 17:37:47

----------------------------------------------------------------------
ICEPRERIP01: datos para Ripley
 
                
+---------------------------------------------------+
|      *** RESULTADOS DEL INFORME       ***         |
+----------------------------------+----------------+
|     DETALLE CALIFICACION         | CALF |  # REG. |
+----------------------------------+------+---------+
| - Registros con informacion      | O.K  |        0
| - Registros sin informacion      | SIN  |  122,770
| - Registros inconsistencias      | INC  |    1,960
+----------------------------------+------+---------+
| - Total Registro procesados             |  122,770
+----------------------------------+------+---------+

real    0m41.86s
user    0m9.51s
sys     0m5.79s

Inicio de Programa:  2014/06/03 17:37:48
Fin de Programa:     2014/06/03 17:38:30

----------------------------------------------------------------------
ARCHIVOS:
 
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 17:38 pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2003 Jun  3 17:38 pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 pripley1.in
-rw-rw-r--   1 icjlud   icdatacr  301840 Jun  3 17:27 pripley1.inc
-rw-rw-r--   1 ichdd    icdatacr    3909 Jun  3 17:38 pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr 16573950 Jun  3 17:37 pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621490 Jun  3 17:26 pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 17:37 pripley1.ULTIMO
-rw-rw-r--   1 icjlud   icdatacr 12989915 Jun  3 17:27 pripley1.val
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 17:26 pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621562 Jun  3 17:07 pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 pripley11.vre
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 17:26 pripley1VALI.prn
 
 
----------------------------------------------------------------------
fin del proceso sh-PE-Ripley
Iniciado: 17:26:40 finalizado: 17:38:30
----------------------------------------------------------------------
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm#*******************************************************************************
#   carga los valores del archivo .parm
    paramsGet
    # lee el set de parámetros hasta la satisfacción del ope
    parmsOK="0"
    while [[ $parmsOK = "0" ]]
    do
  readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo basereadTIPO_ARCHIVO# 0 1-11, 1 1-11-45
else
readTIPO_EXTRACT# N NIT, C cod subsreadID_EXTRACT# NIT o cos subs
fi
readTIPO_PROC# A actual, H histórico
if [[ $TIPO_PROC = "H" ]]
then
readFECHA_INICIO# fecha desde
else
FECHA_INICIO=$FECHA_PROC
fi

paramsPrint # $$$$ DEBUG
sleep 2
# guarda en archivo .parm
paramsPut
clear
echo $raya
# banner "PE Ripley"
echo "$ASCIIBanner"
echo $raya
paramsDisplay
echo $raya
# pregunta al ope si está satisfecho
continuar="_"
while [[ $continuar = "_" ]]
do
  echo " "
echo " "
echo " "
echo "Ingrese 1 para cambiar los parámetros, enter para continuar:\c"read continuarif [[ -z $continuar ]]then
parmsOK="1"
continuar="listo"else    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm
[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>fgprstattop   . visetsh-PE-Ripleyview /dicregis/pva/temporales/pripley1.prn/d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley*                /d/iccol/desarrollo/macros>
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 17:38 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2003 Jun  3 17:38 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 /dicregis/pva/temporales/pripley1.in
-rw-rw-r--   1 icjlud   icdatacr  301840 Jun  3 17:27 /dicregis/pva/temporales/pripley1.inc
-rw-rw-r--   1 ichdd    icdatacr    3909 Jun  3 17:38 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr 16573950 Jun  3 17:37 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621490 Jun  3 17:26 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 17:37 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icjlud   icdatacr 12989915 Jun  3 17:27 /dicregis/pva/temporales/pripley1.val
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 17:26 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 /dicregis/pva/temporales/pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 /dicregis/pva/temporales/pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621562 Jun  3 17:07 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 /dicregis/pva/temporales/pripley11.vre
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 17:26 /dicregis/pva/temporales/pripley1VALI.prn
/d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn
"/dicregis/pva/temporales/pripley11.prn" 124733 lines, 1621562 characters VALIDAR=NO^M
VALIDAR=NO^M
VALIDAR=NO^M
100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914"/dicregis/pva/temporales/pripley11.prn" 124733 lines, 1621562 characters100000058754
100000059035
100000060120[2] + Stopped (SIGTSTP)        vi /dicregis/pva/temporales/pripley11.prn
/d/iccol/desarrollo/macros>^Z
/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn/d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley*               /d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn/d/iccol/desarrollo/macros>
"/dicregis/pva/temporales/pripley11.prn" 124733 lines, 1621562 characters VALIDAR=NO^M
VALIDAR=NO^M
VALIDAR=NO^M
100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914"/dicregis/pva/temporales/pripley11.prn" 124733 lines, 1621562 characters100000058754
100000059035
100000060120"/dicregis/pva/temporales/pripley11.prn" 124730 lines, 1621490 characters /d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn/d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn/d/iccol/desarrollo/macros>ls -l $TEMPORALES/pripley*               /d/iccol/desarrollo/macros>
-rw-rw-r--   1 icdgd    icdatacr     741 May 30 17:37 /dicregis/pva/temporales/pripley.DATINF
-rw-rw-r--   1 icdgd    icdatacr    1971 May 30 17:37 /dicregis/pva/temporales/pripley.ESTADI
-rw-rw-r--   1 icdgd    icdatacr    7700 May 30 14:21 /dicregis/pva/temporales/pripley.inc
-rw-rw-r--   1 icdgd    icdatacr      80 May 30 16:43 /dicregis/pva/temporales/pripley.PREDHD
-rw-rw-r--   1 icdgd    icdatacr     650 May 30 14:21 /dicregis/pva/temporales/pripley.prn
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.val
-rw-rw-r--   1 icdgd    icdatacr       0 May 30 14:21 /dicregis/pva/temporales/pripley.vre
-rw-rw-r--   1 ichdd    icdatacr 1621514 May 30 15:37 /dicregis/pva/temporales/pripley1.COP
-rw-rw-r--   1 ichdd    icdatacr 111106850 Jun  3 17:38 /dicregis/pva/temporales/pripley1.DATINF
-rw-rw-r--   1 ichdd    icdatacr    2003 Jun  3 17:38 /dicregis/pva/temporales/pripley1.ESTADI
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 16:27 /dicregis/pva/temporales/pripley1.in
-rw-rw-r--   1 icjlud   icdatacr  301840 Jun  3 17:27 /dicregis/pva/temporales/pripley1.inc
-rw-rw-r--   1 ichdd    icdatacr    3909 Jun  3 17:38 /dicregis/pva/temporales/pripley1.log
-rw-rw-r--   1 ichdd    icdatacr 7980050 May 30 15:37 /dicregis/pva/temporales/pripley1.ok
-rw-rw-r--   1 ichdd    icdatacr 16573950 Jun  3 17:37 /dicregis/pva/temporales/pripley1.PREDHD
-rw-rw-r--   1 icjlud   icdatacr 1621490 Jun  3 17:26 /dicregis/pva/temporales/pripley1.prn
-rw-rw-r--   1 ichdd    icdatacr     125 Jun  3 17:37 /dicregis/pva/temporales/pripley1.ULTIMO
-rw-rw-r--   1 icjlud   icdatacr 12989915 Jun  3 17:27 /dicregis/pva/temporales/pripley1.val
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 17:26 /dicregis/pva/temporales/pripley1.vre
-rw-rw-r--   1 icdgd    icdatacr 111106850 Jun  3 17:03 /dicregis/pva/temporales/pripley11.DATINF
-rw-rw-r--   1 icdgd    icdatacr    2045 Jun  3 17:03 /dicregis/pva/temporales/pripley11.ESTADI
-rw-rw-r--   1 icdgd    icdatacr     316 Jun  3 17:07 /dicregis/pva/temporales/pripley11.log
-rw-rw-r--   1 icdgd    icdatacr 16573950 Jun  3 16:44 /dicregis/pva/temporales/pripley11.PREDHD
-rw-rw-r--   1 icdgd    icdatacr 1621490 Jun  3 17:49 /dicregis/pva/temporales/pripley11.prn
-rw-rw-r--   1 icdgd    icdatacr     125 Jun  3 16:44 /dicregis/pva/temporales/pripley11.ULTIMO
-rw-rw-r--   1 icdgd    icdatacr       0 Jun  3 16:33 /dicregis/pva/temporales/pripley11.vre
-rw-rw-r--   1 icjlud   icdatacr 1621514 Jun  3 17:26 /dicregis/pva/temporales/pripley1VALI.prn
/d/iccol/desarrollo/macros>vi /dicregis/pva/temporales/pripley11.prn
"/dicregis/pva/temporales/pripley11.prn" 124730 lines, 1621490 characters 100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914
100000058754
100000059035
100000060120"/dicregis/pva/temporales/pripley11.prn" 124730 lines, 1621490 characters:q/d/iccol/desarrollo/macros>^[  /d/iccol/desarrollo/macros>/^shsh-PE-Ripley
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
>>>> params:  E;pripley11.prn;1;C;123456;A;20140603
 
                       ORIGEN DE LA BASE
----------------------------------------------------------------------
      I) Interna
      E) Externa, provista por el Cliente
      enter=E
 
            BASE:E
            BASE:
 
                       NOMBRE DEL ARCHIVO BASE
----------------------------------------------------------------------
      Ingrese el nombre del archivo base,
      enter=pripley11.prn
 
            ARCHIVO:pripley11.prn
            ARCHIVO:
 
                    ESTRUCTURA DEL ARCHIVO BASE
----------------------------------------------------------------------
      1) 1-11
      2) 1-11-45
      enter=1
 
            ESTRUCTURA:1
            ESTRUCTURA:1
 
                          TIPO DE PROCESO
----------------------------------------------------------------------
      A) Proceso actual
      H) Proceso histórico
      enter=A
 
            TIPO de PROCESO:A
            TIPO de PROCESO:
BASE=E<
NOM_ARCHIVO=pripley11.prn<
TIPO_ARCHIVO=1<
TIPO_EXTRACT=C<
ID_EXTRACT=123456<
TIPO_PROC=A<
FECHA_INICIO=20140603<
E;pripley11.prn;1;C;123456;A;20140603
file: sh-PE-Ripley.parm  in: /d/iccol/desarrollo/macros
----------------------------------------------------------------------

        ######  #######    ######
        #     # #          #     # # #####  #      ###### #   #
        #     # #          #     # # #    # #      #       # #
        ######  #####      ######  # #    # #      #####    #
        #       #          #   #   # #####  #      #        #
        #       #          #    #  # #      #      #        #
        #       #######    #     # # #      ###### ######   #

----------------------------------------------------------------------
PARÁMETROS del PROCESO
    Fecha=20140603
    Archivo: pripley11.prn
    Base: E  provista por el cliente
    Estructura: 1  1-11
    Tipo de proceso: A  actual
----------------------------------------------------------------------
 
 
 
Ingrese 1 para cambiar los parámetros, enter para continuar:
----------------------------------------------------------------------
PESVNO: validación de IDs
Input PESVNO: pripley11.prn
PESVNO pripley11VALI.prn pripley11.val pripley11.inc 10 2

real    0m9.19s
user    0m5.88s
sys     0m3.04s
PESVNO - registros válidos: 122770  inconsistentes: 1960  total: 124730
REGISTROS NO EXISTEN   BDIIREGI :0000002
REGISTROS NO EXISTEN   BDIIDIAN :0000001
TIPO IDENTIFICACION INVALIDO    :0000000
===================================
ACTUALIZANDO REGIS PARA FACTURACION
===================================
FECHA : 20140603
HORA  : 1751
===================================
ABRIENDO ARCHIVO :$DATOS/LOGPESVNO.DAT                  - 00
RESULTADO OPERACION :$DATOS/LOGPESVNO.DAT                  - 00
Graba Tipo 5    ==> 000000122770
Graba Tipo 6    ==> 000000001957
Graba Tipo 7    ==> 000000000003
Graba Tipo 5 PJ ==> 000000003034
TRANSAC-STATUS-WK: OK

Inicio de Programa:  2014/06/03 17:51:09
Fin de Programa:     2014/06/03 17:51:19

----------------------------------------------------------------------
SCOTBATCH: cálculo de scores
 
SCOTBATCH 201406 067 VAL pripley11.val
^C/d/iccol/desarrollo/macros>fg
vi /dicregis/pva/temporales/pripley11.prn
100000000480
100000000584
100000001415
100000003849
100000006212
100000008689
100000009441
100000009750
100000010237
100000011033
100000011586
100000013546
100000014484
100000014551
100000014921
100000015661
100000016555
100000017790
100000022201
100000022998
100000025714
100000028584
100000028854
100000030832
100000030869
100000032384
100000033144
100000033824
100000033993
100000034227
100000036102
100000036138
100000039411
100000039972
100000042409
100000045413
100000045551
100000048123
100000048263
100000051899
100000052162
100000052452
100000053080
100000055197
100000055346
100000055914
100000058754
100000059035
100000060120:q:"/dicregis/pva/temporales/pripley11.prn" 124730 lines, 1621490 characters /d/iccol/desarrollo/macros>jobs
[1] + Stopped (SIGTSTP)        vi sh-PE-Ripley
/d/iccol/desarrollo/macros>fg
vi sh-PE-Ripley
    # $$$$ DEBUG: regex que extrae TODOS los registros[[ $debug = 1 ]] && grepRegex='.*'
    echo grep "$grepRegex" $ICMCRECOPY \| cut -c8-19 \| sort -u
    grep "$grepRegex" $ICMCRECOPY | cut -c8-19 | sort -u >| $archivo_prn
    # cuenta los registros extraídos
    cantRegsExtraidos=$(wc -l < $archivo_prn)
    echo "Registros extraídos: "$cantRegsExtraidos
    TIPO_ARCHIVO="1"  # es un archivo 1-11
}

ejecutar_validacion() {
#*******************************************************************************
# PESVNO: validación de IDs
# Valida los registtros del archivo .prn y graba archivos .val y .inc
#*******************************************************************************
    echo "Input PESVNO: "$archivo_prn
    # si el input tiene estructura 1-11 le antepone el REGPESVNO.VALI grabando
    # un archivo ...VALI.prn con el registro de control adelante
    if [[ $TIPO_ARCHIVO = "1" ]]
    then
PESVNO_INPUT=${archivo}"VALI.prn"
cat $DATOS/REGPESVNO.VALI $archivo_prn >| $PESVNO_INPUT
    else
PESVNO_INPUT=$archivo_prn
    fi

echo PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2
    $NOHUP x PESVNO $PESVNO_INPUT $archivo_val $archivo_inc 10 2 >| $archivo.log
    cantDeRegistrosTotal=$(wc -l < $archivo_prn)
    cantDeRegistrosVal=$(wc -l < $archivo_val)
    cantDeRegistrosInc=$(wc -l < $archivo_inc)
    echo "PESVNO - registros válidos:" $cantDeRegistrosVal " inconsistentes:" $cantDeRegistrosInc " total:
" $cantDeRegistrosTotal
    tail -20 $archivo.log
    if [[ $cantDeRegistrosTotal -ne $(expr $cantDeRegistrosVal + $cantDeRegistrosInc ) ]]
    then
echo " "
echo $raya
echo "Las cantidades de registros no cuadran: proceso cancelado"
echo $raya
cancelado="1"
    fi
}

leerParametros() {
#*******************************************************************************
# Interacción con el operador para cargar/editar el set de parámetros
#*******************************************************************************
#   carga los valores del archivo .parm
paramsGet    
# lee el set de parámetros hasta la satisfacción del ope    
parmsOK="0"    
while [[ $parmsOK = "0" ]]    
do
readBASE# I interna, C cliente
if [[ $BASE = "E" ]]
then
readNOM_ARCHIVO# nombre del archivo base
readTIPO_ARCHIVO# 0 1-11, 1 1-11-45

    



INSERT MODE# :w"sh-PE-Ripley" 758 lines, 26943 characters 

 line 495 of 758 --65%-- :q/d/iccol/desarrollo/macros>^D
